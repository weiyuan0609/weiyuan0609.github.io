<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[迭代复盘方式]]></title>
    <url>%2F2021%2F01%2F06%2F%E8%BF%AD%E4%BB%A3%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[迭代复盘方式如下：]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微前端的价值和实践]]></title>
    <url>%2F2020%2F11%2F23%2F%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[考量到目前公司项目多，技术栈杂，体验不太友好，所以花了点时间大概研究了下微前端 大概分下面几个部分简单阐述下我的理解，算是自我小结吧： 微前端的简介 微前端的价值 微前端需要解决的问题 微前端的技术选型 微前端的实践总结 微前端存在的问题 1. 微前端的简介微前端是一种类似于微服务的架构体系 它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用 各个前端应用还可以独立开发、独立部署 2. 微前端的价值 解耦：方便扩展，重构，替换，组合 旧项目里开发新模块 新项目怎么架构，在 3-5 年不会变成遗产项目 与业务组件有什么区别：技术无关 复用：能力输出 服务化 复用的层级 函数逻辑复用（模块化） 通用方法 业务方法 组件复用（组件化） 通用组件：antd，日期选择组件 业务组件 业务块复用（微前端） 通用业务块：财务，用户信息 服务化 编排服务、编排逻辑、编排组件、编排访问策略、编排流程 3. 微前端需要解决的问题 微应用的注册、异步加载和生命周期管理； 微应用之间、主从之间的消息机制； 微应用之间的安全隔离措施； 微应用的框架无关、版本无关； 微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理； 微应用独立调试、和主应用联调的方式，快速定位报错（发射问题）； 微应用的发布流程； 微应用打包优化问题； 微应用专有云场景的出包方案； 渐进式升级：用微应用方案平滑重构老项目 4. 微前端的技术选型 服务端集成：如 SSR 拼装模板 构建时集成：如 Code Splitting 发布阶段耦合，不推荐使用 运行时集成：如通过 iframe、JS、Web Components 等方式 iframe Web Components JS：比如前端路由 4.1 目前我们项目痛点现状：MPA（多页面应用） + SPA（单页面应用） 痛点在于： 历史包袱重，人员更替频繁 项目多，技术栈杂、老旧 还存在大量 php 页面，未实现前后端分离 4.2 对我们公司的价值4.2.1 优点 技术价值 使公司技术基础设施更开放，更容易引入优秀开源技术 提高团队技术水平 减少跨项目代码冲突问题 产品价值 跨产品共享模块 进一步优化产品交互体验 增加基座层，优化体验 全局loading 提取菜单，顶部，底部 提取公共库 预加载所有子项目文件 4.2.2 缺点 增加复杂度 增加流量成本 代码库数量增多，管理成本增加 开发环境复杂 5. 微前端的实践总结5.1 qiankun 5.2 怎么解决微前端的问题 基座模式（主从应用）：就是在子应用之前加一层（基座层）注册子应用，添加子应用生命周期（运行时集成） 路由控制 通过唯一的子应用入口地址，获取要加载的资源（HTML Entry 方案） 样式隔离：切入插入样式，切出/卸载删除样式表，浏览器会自动刷新cssom js 隔离：proxy/快照 预加载/按需加载 父子应用通信 5.3 实践中遇到的问题 Entry 唯一：域名或端口不相同 开发环境允许跨域：disableHostCheck，headers package.json 中的 name 要唯一 静态资源应该是完整的资源地址 6. 微前端存在的问题 微前端拆分的粒度 微前端的源码怎么管理 微前端可以嵌套，要怎么拆分 提取菜单、顶部，子应用不独立了，怎么办 借用同事的一句话总结下： 没有银弹，只是多了一个权衡的维度]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>微前端</tag>
        <tag>qiankun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解前端模块加载机制，手写 node.js 的 require 函数]]></title>
    <url>%2F2020%2F08%2F11%2Fnode-require%2F</url>
    <content type="text"><![CDATA[1. 模块化的演进模块化特点的特点是什么？ 防止变量污染 在以前的开发中，如果不用模块化，我们无法处理依赖关系，所以代码很难维护 那最早的时候我们是使用 单例 的方式解决，但是有个缺点，我们不能保证变量的唯一性，而且单例可能导致调用时浮躁，命名过长等问题, 如下方代码所示： 1234567891011const a = &#123; m: 'test', get: function() &#123; ... &#125;, ...&#125;const a1234455 = &#123; ....&#125; 当然，我们还有用到了 IFFE（立即执行函数）来处理这个问题 1234(function(a)&#123; console.log('ddd', a); .....&#125;)() 再近点，就出现了一些解决模块化的第三方库，下面两种，在现在未前后端分离的项目（也就是 mvc 模式下 jquery 项目）还是会见到的。 seajs库 cmd(就近依赖，只有在用到某个模块的时候再去require) requirejs库 amd(依赖前置， 在定义模块的时候就要声明其依赖的模块) 这里不多说了，感兴趣的可以百度了解下这两个库。 那当下 vue, react 框架流行下，我们是如何来处理模块化的呢？ 结论是： umd（统一模块化），常见的是 es6 module（node 中无法使用） 和 commonjs 规范 如果想要在 node 中使用 es module，也就是 import 和 export，怎么办呢？ node 官网提供了一个 ECMAScript模块，它需要将文件后缀改成 .mjs，来支持 import 导入的方式，但是目前还是实验版。 还有一种方式，就是使用 babel-node 来转化 es6 模块。 1.1 commonjs 规范特点是啥，往下看？ 每个 js 文件都是一个模块 每个文件如果需要用到别的模块 require() 想把代码给别人使用 需要导出模块 module.exports 那文件之间是怎么隔离的？ 其实很简单，就是给当前文件代码加了个闭包来隔离 1234567891011121314151617(function()&#123; let module = &#123; exports: &#123;&#125; &#125; module.exports = 'hello' return module.exports&#125;)()let file = require('./a.js')// 大概效果如下let file = require((function()&#123; let module = &#123; exports: &#123;&#125; &#125; module.exports = 'hello' return module.exports&#125;)()) 2. fs path vm 等 node 模块这里为什么单独介绍下这几个模块，因为这几个是核心模块，看过源码，你就知道， require 的实现就需要用到这几个模块。 path path 模块提供了一些实用工具，用于处理文件和目录的路径 具体可看：path 文档 fs fs 模块可用于与文件系统进行交互（以类似于标准 POSIX 函数的方式）。 具体可看：fs 文档 vm vm 模块可在 V8 虚拟机上下文中编译和运行代码。 vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 具体可看：vm 文档 vm 模块这里单独提下， 我们回忆下让字符串执行的方法有哪些? eval 12let a = 1;eval('console.log(a)') new Function 12let strFn = new Function('console.log(a)')strFn(); vue 模板引擎的实现原理就是 new Function + with vm vm 沙箱，创造一个干净的执行上下文环境，不会向上查找 1vm.runInThisContext(str) 3. require 实现过程3.1 断点调试这里简单提下如何断点调试，不方便展示，大家可以网上翻阅下文档 我用的 vscode, 需要配置下 launch.json 文件，下面是我的配置 1234567891011121314&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "Client", "program": "$&#123;workspaceFolder&#125;/app.js" &#125; ]&#125; 然后运行 debug 模式，就可以查看源码，面板如下所示 3.2 require 执行过程 加载时 先看一下模块是否被缓存过 第一次没有缓存过 Module._resolveFilename 解析出当前引用文件的绝对路径 是否是内置模块，不是就创建一个模块 模块有两个属性 一个叫 id = 文件名， exports = {} 将模块放到缓存中 加载这个文件 Module.load 拿到文件的扩展名 findLongestRegisteredExtension() 根据扩展名来调用对应的方法 会读取文件 差一个加一个自执行函数，将代码放入 3.3 手写 require 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// a.js 文件module.exports = 'hello';console.log('加载了一次');// require.js 文件let fs = require('fs');let path = require('path');let vm = require('vm');function Module(id) &#123; this.id = id; // 文件名 this.exports = &#123;&#125;; // exports 导出对象&#125;Module._resolveFilename = function(filename) &#123; // 应该去依次查找 Object.keys(Module._extensions) // 默认先获取文件的名字 filename = path.resolve(filename); // 获取文件的扩展名 并判断是否有，若没有就是.js,若有，就采用原来的名字 let flag = path.extname(filename); let extname = flag ? flag : '.js'; return flag ? filename : (filename + extname);&#125;Module._extensions = Object.create(null);Module.wrapper = [ '(function(module,exports,require,__dirname,__filename)&#123;', '&#125;)']Module._extensions['.js'] = function(module) &#123; // id exports // module.exports = 'hello' let content = fs.readFileSync(module.id, 'utf8') let strTemplate = Module.wrapper[0] + content + Module.wrapper[1]; // console.log('111', strTemplate); // 希望让这个函数执行，并且，我希望吧exports 传入进去 let fn = vm.runInThisContext(strTemplate); // 模块中的 this 就是 module.exports的对象 fn.call(module.exports, module, module.exports, requireMe);&#125;// json 就是直接将结果放到 module.exports 上Module._extensions['.json'] = function(module) &#123; let content = fs.readFileSync(module.id, 'utf8'); module.exports = JSON.parse(content);&#125;Module.prototype.load = function() &#123; // 获取文件的扩展名 let extname = path.extname(this.id); Module._extensions[extname](this);&#125;Module._cache = &#123;&#125;; // 缓存对象function requireMe(filename) &#123; let absPath = Module._resolveFilename(filename); // console.log(absPath); if (Module._cache[absPath]) &#123; // 如果缓存过了，直接将exports 对象返回 return Module._cache[absPath].exports; &#125; let module = new Module(absPath); // 增加缓存模块 Module._cache[absPath] = module; // 加载 module.load(); return module.exports; // 用户将结果赋予给 exports 对象上 默认 require 方法会返回 module.exports 对象&#125;let str = requireMe('./a');str = requireMe('./a');console.log('===', str); 4. module.exports 与 exports 关系exports 是 module.exports 一个简写 常用的导出方式 exports.xxx = xxxmodule.exportsmodule.exports.a = xxxglobal.a = xxx（可以，但不会用，全局污染）exports = xxx(错误) 5. 模块查找方式有几种模块： 内置模块 fs path vm 文件模块 自定义模块 ‘./‘ 第三方模块 （bluebird….）必须安装才能使用， 用法和内置模块是一样的 方式： 先查找当前文件下的文件存不存在，不存在 添加 .js .json 后缀 找到后就结束 找不到后会找对应的文件夹，默认找索引文件，如果有package.json ，有这个文件，会查找 main对应的入口文件，去进行加载 按照包的方法查找 多个文件组成一个包 npm init -y 除了文件的查找方式 第三方模块的查找方式 123let r = require('xxx') // xxx表示的是第三方文件夹的名字，找到名字后会找package.json ,如果找不到向上找，找不到就报错。console.log(module.paths); // 查看效果]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle 抓包实践]]></title>
    <url>%2F2020%2F06%2F10%2Fwhistle%E6%8A%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. 介绍whistle 是一款用 Node 实现的跨平台的 Web 调试代理工具。简而言之就是 Node 版的 Fiddler、Charles，不过这个工具我觉得使用更简单、功能也更加实用，而且我觉得比 Fiddler、Charles 更加好用。 whistle 文档 2. 安装&amp;运行2.1 安装 node2.2 安装 whistle1npm install -g whistle 2.3 启动 whistle1w2 start 2.4 安装证书电脑打开浏览器，输入网址：http://127.0.0.1:8899/，点击HTTPS，安卓手机可以直接通过手机浏览器扫描二维码下载安装证书或者在浏览器网址中输入 rootca.pro，下载证书。 要是实在下载不下来，就通过电脑浏览器下载证书，将证书复制黏贴到手机，点击证书安装。 2.5 手机配置 wifi 代理 2.6 效果展示 这样基本的抓包功能就 ok 了。 3. 代理 代理请求支持域名 ip 以及本地文件，在日常调试中极为方便： 比如代理线上某个 js css html 文件在本地修改，可做到实时调试 比如将生产接口返回的 json 保存在本地，然后在测试环境进行调试 … 4. 注入代码先准备需要注入的代码片段，之后配置规则]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>whistle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-生产环境构建优化]]></title>
    <url>%2F2020%2F05%2F18%2Fwebpack-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[刚刚对我们前端项目做了一顿分析优化操作，因为接手时每次构建要花两分钟左右的时间，实在忍受不了，只能动手了。通过这次优化，重新温习了下 webpack 的一些知识。接下来会关于 webpack 展开写几篇心得： 构建分析 开发环境构建优化 生产环境构建优化 webpack 原理浅析 如何实现一个简易版 webpack 如何手写一个 loader 和 plugin 好了，进入主题，本篇主要是介绍生产环境构建优化（包含速度、体积）。 1. 版本升级建议更新到最新稳定版本，为什么呢？可以看我上一篇开发环境构建优化。 2. devtool不设置 devtool 或者设置如下： 1234module.exports = &#123; devtool: 'none', // ...&#125; 为什么呢？可以看我上一篇开发环境构建优化。 3. optimization 优化optimization 介绍 一些 plugin 比如压缩混淆在开发环境是没有意义的，所以需要写两份不同的配置文件，防止这些插件作用在开发环境。 以下配置用于生产环境，可以优化生产环境构建： 123456789101112131415161718192021222324module.exports = &#123; // ... optimization: &#123; minimize: true, splitChunks: &#123; chunks: 'all', minSize: 30000, automaticNameDelimiter: '-', cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, priority: 10, name: 'vendors' &#125; &#125; ... &#125;, runtimeChunk: &#123; name: "manifest" &#125; ... &#125;, // ...&#125; 4. clean-webpack-plugin用于清除之前构建生成的 dist 目录的文件。 12345678910var CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; // ... plugins: [ new CleanWebpackPlugin(['dist/pc/*.*'], &#123; root: path.resolve(__dirname, '../') &#125;), ]&#125;; 5. HashedModuleIdsPlugin该插件会根据模块的相对路径生成一个四位数的 hash 作为模块 id, 建议用于生产环境。具体可以看官网 123456module.exports = &#123; // ... plugins: [ new webpack.HashedModuleIdsPlugin(), ]&#125;; 6. DllPlugin注意：重要优化手段, 是什么，这里不做介绍了，可以查看官网介绍 下面是我的一些配置，可以参考下： 123456789101112131415161718192021222324252627// webpack.dll.jsmodule.exports = &#123; // ... plugins: [ new webpack.DllPlugin(&#123; context: path.resolve(__dirname, '../'), name: '__dll__[name]', path: path.join(__dirname, '../dist/dlls/', '[name].manifest.json') &#125;), ]&#125;;// webpack.prod.jsmodule.exports = &#123; plugins: [ new webpack.DllReferencePlugin(&#123; context: path.resolve(__dirname, '../'), name: '__dll__vendors', manifest: path.join(__dirname, '../dist/dlls/', 'vendors.manifest.json') &#125;), new webpack.DllReferencePlugin(&#123; context: path.resolve(__dirname, '../'), name: '__dll__baiduMap', manifest: path.join(__dirname, '../dist/dlls/', 'baiduMap.manifest.json') &#125;) ]&#125; 7. assets-webpack-plugin使用 DLL &amp; DllReference 后，第三方库的确前置构建了，但是如何让打包出来的 bundle 文件在 index.html 中引用呢？如果 output.fileName 写死名字，在 index.html 中也写死，就没有了强缓存，如果 ouput.fileName=[name].[hash].js，就得找到一个往 html 里添加 js 的办法 有了这个插件，看起来就行得通了，在打包第三库时使用 assets-webpack-plugin 将 bundle 的文件名输出，保存成 json，在打包业务代码时配合 html-webpack-plugin 插件，将 bundle 添加到 index.html 中 该插件生成一个记录了版本号的文件；详细的可以看官网地址 12345678910var AssetsPlugin = require('assets-webpack-plugin');module.exports = &#123; plugins: [ new AssetsPlugin(&#123; filename: 'dll-bundle.json', path: path.resolve(__dirname, './') &#125;) ]&#125; 我的 dll-bundle.json 如下： 1&#123;"baiduMap":&#123;"js":"/dist/dlls/baiduMap.dll.6c409412.js"&#125;,"vendors":&#123;"js":"/dist/dlls/vendors.dll.6c409412.js"&#125;&#125; 8. 其他我上一篇开发环境用到的文件压缩和 CDN …，这些在生产环境也可以用，看你的需求了。 大家还有没有其他的优化黑魔法，欢迎大家留言交流，共同学习成长。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-开发环境构建优化]]></title>
    <url>%2F2020%2F05%2F06%2Fwebpack-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[刚刚对我们前端项目做了一顿分析优化操作，因为接手时每次构建要花两分钟左右的时间，实在忍受不了，只能动手了。通过这次优化，重新温习了下 webpack 的一些知识。接下来会关于 webpack 展开写几篇心得： 构建分析 开发环境构建优化 生产环境构建优化 webpack 原理浅析 如何实现一个简易版 webpack 如何手写一个 loader 和 plugin 好了，进入主题，本篇主要是介绍开发环境构建优化（包含速度、体积），如何分析可以看我上一篇。 1. 版本升级现在，我们已经可以安装最新的 webpack 5 了，不过 v5 还不是正式版本。目前 npm 官网上的最新版本仍然是 v4。由于不是本章重点，后面有机会会详细阐述，感兴趣的可以看下这篇文章了解下，最好能动手玩一玩。 建议更新到最新稳定版本，为什么呢？可以看下官网-构建性能 所以别说 v3 了, webpack4.x 的速度要远大于 3.x, v4 的小版本也建议更新到最新稳定版。 另外 webpack 版本也会存在导致本地使用 node 高版本跑项目时，报出一些奇奇怪怪的错误。像我遇到过一次 webpack v4.6、node v12.16.0 就报错了。 2. devtool1234module.exports = &#123; devtool: 'eval-source-map', // ...&#125; 开发环境建议使用 eval-source-map, 这会减少你本地构建的时间。 为什么呢？可以看下官网介绍-devtool,这部分的中文是我负责翻译的，有觉得不合理的，欢迎留言。 3. resolve建议配置 alias 和 extensions，同时项目中要使用到 alias，否则配置就毫无意义了。 12345678910111213141516171819module.exports = &#123; // ... resolve: &#123; alias: &#123; src: path.resolve(__dirname, '../src'), page: path.resolve(__dirname, '../src/page'), mobilepage: path.resolve(__dirname, '../src/mobilepage'), components: path.resolve(__dirname, '../src/components'), containerComponents: path.resolve(__dirname, '../src/containerComponents'), store: path.resolve(__dirname, '../src/store'), static: path.resolve(__dirname, '../src/static'), vue: 'vue/dist/vue.js', utils: path.resolve(__dirname, '../src/utils') // ... &#125;, extensions: [".js", ".vue"] &#125;, // ..&#125; 可以看下 webpack-缩小范围 官网-resolve 4. 避免不必要的 plugin 和优化任务一些plugin比如压缩混淆在开发环境是没有意义的，所以需要写两份不同的配置文件，防止这些插件作用在开发环境。 另外需要防止不必要的优化，可以在开发环境把这些都关掉。 123456789module.exports = &#123; // ... optimization: &#123; removeAvailableModules: false, removeEmptyChunks: false, splitChunks: false &#125;, // ...&#125; 5. happypackhappypack 在使用 Webpack 对项目进行构建时，会对大量文件进行解析和处理。当文件数量变多之后，Webpack 构件速度就会变慢。由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以 Webpack 需要处理的任务要一个一个进行操作。 而 Happypack 的作用就是将文件解析任务分解成多个子进程并发执行。子进程处理完任务后再将结果发送给主进程。所以可以大大提升 Webpack 的项目构件速度。 这里顺带提一下，在 loader 中最好加上 exclude 和 include 配置，会减少构建时间的。 123456789101112131415161718192021222324252627282930var path = require('path');var HappyPack = require('happypack');module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\.js$/, use: 'happypack/loader', include: [ path.resolve(__dirname, '../src'), // ... ], exclude: /node_modules/ &#125;, // ... ] &#125;, resolve: &#123; // ... &#125;, plugins: [ // ... new HappyPack(&#123; loaders: ['babel-loader'], threads: 4 &#125;), ]&#125;; 6. 使用 noParsewebpack 打包的时候，有时不需要解析某些模块的加载(这些模块并没有依赖，或者根本没有模块化)，我们可以直接加上这个参数，直接跳过这种解析，像 jquery、lodash… 1234module.exports = &#123; noParse: /node_modules\/(jquery.js) // ...&#125; 7. hard-source-webpack-pluginhard-source-webpack-plugin 这是用于加载缓存，效果很强。 第一次构建将花费正常的时间 第二次构建将显着加快（大概提升90%的构建速度）。 webpack v5 实现了此功能，感兴趣的可以下载试试。 12345678var HardSourceWebpackPlugin = require('hard-source-webpack-plugin');module.exports = &#123; // ... plugins: [ new HardSourceWebpackPlugin(), // 缓存，每当程序包依赖性发生变化时，请记住清除缓存 ]&#125;; 8. 压缩 js, html, css 文件要想优化构建后的体积，不断减少静态资源文件的大小，我们希望 webpack 帮助我们尽可能压缩文件的体积。对于 js 脚本文件而言，webpack4.0 在 mode 为 ‘production’ 时，默认会启动代码的压缩。除此之外，我们需要手动对 html 和 css 进行压缩。 针对html 的压缩，只需要对 html-webpack-plugin 进行相关配置。 123456789101112131415module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; title: 'webpack优化', filename: 'index.html', template: path.resolve(__dirname, '../index.html'), minify: &#123; // 压缩 HTML 的配置 collapseWhitespace: true, removeComments: true, useShortDoctype: true &#125; &#125;), ] // ...&#125; 针对 css 的压缩， webpack4.0 使用 optimize-css-assets-webpack-plugin 来压缩单独的 css 文件。 1234567const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");module.exports = &#123; plugins: [ new OptimizeCSSAssetsPlugin() ],&#125; 9. 合并压缩图片提升性能的一个重要的条件是降低 http 请求数，而应用中经常会有大大小小的图片需要处理，对应用中的小图标来说，css sprite 是首选，将各种图标集合成一张大的图片可以很好的减少网络请求数。而对于需要独立开的图片，且大小在合理范围内时，我们可以将图片转换成 base64 位编码，内嵌到css 中，同样可以减少请求。 处理图片资源时，webpack 提供了 file-loader 和url-loader 两个loaders供选择，file-loader 和url-loader 的作用，可以用来解析项目中图片文件的url引入问题。两者的区别在于，url-loader 可以将小于指定字节的文件转为 DataURL, 大于指定字节 的依旧会使用 file-loader 进行解析 123456789101112131415module.exports = &#123; // .. module: &#123; rules: [&#123; test: /\.(png|jpe?g|gif|svg|ttf|woff2|woff)(\?.*)?$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 8192, outputPath: 'assets/fonts/' &#125; &#125;, ] &#125;,&#125; 处理完雪碧图和小图片的 base64 转换后，对于大图片来说，webpack还可以做到对图片进行压缩，推荐使用 image-webpack-loader,插件提供了多种形式的压缩。 12345678910111213141516171819// webpack.base.jsmodule.exports = &#123; module: &#123; rules: [ &#123; loader: 'image-webpack-loader', options: &#123; optipng: &#123; // 使用 imagemin-optipng 压缩 png，enable: false 为关闭 enabled: true, &#125;, pngquant: &#123; // 使用 imagemin-pngquant 压缩 png quality: '65-90', speed: 4 &#125;, &#125; &#125; ] &#125;&#125; 10. 使用 CDN在项目的 index.html 中，常规方式引入 CDN 链接，此处以 jquery 为例 12345&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- CDN方式引入jquery --&gt; &lt;script src="https://.../jquery@2.13.2/lib/index.js"&gt;&lt;/script&gt;&lt;/body&gt; 使用 externals 123456module.exports = &#123; //... externals: &#123; jquery: 'jQuery' &#125;&#125;; 使用时 123import $ from 'jquery';$('.my-element').animate(/* ... */); 11. progress-bar-webpack-pluginprogress-bar-webpack-plugin 最后推荐个构建体验插件-构建进度条 123456789var ProgressBarPlugin = require('progress-bar-webpack-plugin');module.exports = &#123; // ... plugins: [ new ProgressBarPlugin(), //... ]&#125;; 最后，目前说了大概 10 种开发环境构建速度和体积的优化。关于体积部分，生产环境也会用到。 大家还有没有其他的优化黑魔法，欢迎大家留言交流，共同学习成长。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-构建分析]]></title>
    <url>%2F2020%2F04%2F26%2Fwebpack-%E6%9E%84%E5%BB%BA%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[刚刚对我们前端项目做了一顿分析优化操作，因为接手时每次构建要花两分钟左右的时间，实在忍受不了，只能动手了。通过这次优化，重新温习了下 webpack 的一些知识。接下来会关于 webpack 展开写几篇心得： 构建分析 开发环境构建优化 生产环境构建优化 webpack 原理浅析 如何实现一个简易版 webpack 如何手写一个 loader 和 plugin 好了，进入主题，本篇主要是介绍如何做构建分析。 1. webpack 官网提供的分析工具webpack 官网提供了 stats.json 文件帮助分析打包结果， 使用下面的命令生成 stats.json 文件。 该命令首先使用 webpack 对文件进行打包，然后将打包后的文件模块进分析，并将分析后的结果以 json 的形式输出到 stats.json 文件。 1webpack --profile --json &gt; compilation-stats.json 具体如何分析可参考 webpack - stat 说明, 同时官方还提供了 分析工具，通过上传生成的 stats.json 文件，可以更直观的分析打包模块。如下图所示。 我是用下面两个第三方 plugin 来做分析的。 2. webpack-bundle-analyzer该 plugin 可以更方便的查看模块打包的情况. 2.1 如何使用 安装 1npm install webpack-bundle-analyzer -D 分析已经存在的 stats.json 文件 1webpack-bundle-analyzer stats.json 打包后进行分析。这种情况需要在 webpack 的配置文件中添加配置 123456789const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPluginmodule.exports = &#123; // ... plugins: [ // ... new BundleAnalyzerPlugin(&#123;/** 配置 **/&#125;) ]&#125; 2.2 效果展示 2.3 配置信息配置信息可参考 官网介绍，这里就不做过多介绍了。 3. speed-measure-webpack-plugin该 plugin 可以在打包过程中对使用的 loader 和 plugin 进行打包速度分析。 3.1 如何使用 安装 1npm install speed-measure-webpack-plugin -D 使用 1234567891011const SpeedMeasurePlugin = require('speed-measure-webpack-plugin');const smp =new SpeedMeasurePlugin(&#123;/**配置**/&#125;);module.exports = smp.wrap(&#123; module: &#123; // ... &#125;, plugins: [ // ... ]&#125;); 3.2 效果展示 通过上面的分析，发现包平均构建有 12 M左右, 构建时间偶尔会有 1 分 30 多秒的高光表现。下篇会介绍我的优化过程。 对于 webpack 构建分析还有什么好的方式，欢迎各位大佬留言探讨。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次公司 node 实现 BFF 的分享]]></title>
    <url>%2F2020%2F04%2F18%2Fwrk%2F</url>
    <content type="text"><![CDATA[最近公司有一个团队要搭建 bff 层，顺应了他们的要求，准备了一波分享。 具体从当前业务痛点、BFF 是什么、解决了什么问题、实现一个 BFF 要做哪些事情这几个方面去讲解。 项目演示： https://github.com/weiyuan0609/egg-server-template wrkppt 中有提到 wrk 这个工具，这里做个具体的讲解 我用的是 mac, 所以下面都是基于此系统来讲解的 1. wrk 介绍wrk 是一个用来做 HTTP benchmark 测试的工具。可以产生显著的压力。相比于 Apache ab 功能更为强大，可以使用 lua 脚本来支持更为复杂的测试场景，例如 POST 请求等。在对于 Restful 架构的 API 接口来说，测试起来更加便捷。 2. 下载 wrkbrew install wrk 如果这里卡住，可以调整 123456789# 替换brew.git:cd "$(brew --repo)"git remote set-url origin https://mirrors.ustc.edu.cn/brew.git# 替换homebrew-core.git:cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 再执行一次 brew install wrk 即可 3. 使用方式可以使用 wrk -help 查看 1234567891011121314使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt; Options: -c, --connections &lt;N&gt; 跟服务器建立并保持的TCP连接数量 -d, --duration &lt;T&gt; 压测时间 -t, --threads &lt;N&gt; 使用多少个线程进行压测 -s, --script &lt;S&gt; 指定Lua脚本路径 -H, --header &lt;H&gt; 为每一个HTTP请求添加HTTP头 --latency 在压测结束后，打印延迟统计信息 --timeout &lt;T&gt; 超时时间 -v, --version 打印正在使用的wrk的详细版本信息 &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G) &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)` 4. 测试1wrk -t8 -c500 -d2s --latency "http://localhost:8080/test" 我这服务跑在本地 http://localhost://8080 采用 8 个线程，500个长链接，压测 2 秒 1234567891011121314Running 2s test @ http://localhost:8080/test 8 threads and 500 connections Thread Stats Avg Stdev Max +/- Stdev Latency 40.70ms 9.60ms 83.48ms 66.26% Req/Sec 640.89 328.89 1.43k 64.29% Latency Distribution 50% 31.15ms 75% 23.46ms 90% 62.23ms 99% 85.23ms 7920 requests in 2.07s, 2.02MB read Socket errors: connect 253, read 201, write 0, timeout 0Requests/sec: 3322.60Transfer/sec: 1.60MB 可以看出 2s 内完成了 7920 个请求，2.02mb 的数据读取 当然你也可以用 lua 脚本个性化测试,这里不做过度的讲解，有兴趣可以去学习下 wrk 使用方便，结果清晰。并且因为非阻塞 IO 的使用，可以在普通的测试机上创建出大量的连接，从而达到较好的压测效果。 同时又做过极限压测，出现了 OOM 的情况，记得 Node.js 版本还是 12.x 版本]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>wrk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise 的那些事]]></title>
    <url>%2F2020%2F03%2F25%2Fpromise%2F</url>
    <content type="text"><![CDATA[1. promise 的由来1.1 异步我们都知道 js 是单线程的，也就是说一次只能完成一件任务。如果有多个任务，就必须排队，等待前面一个任务完成，再执行后面一个任务。 这种方式虽然实现起来比较简单，执行环境相对单纯，但是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 js 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 为了解决这个问题，js 语言将任务的执行模式分成两种：同步和异步（异步任务不具有”堵塞“效应）。 “异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降，很快就会失去响应。 1.2 处理异步的几种方式 使用回调函数 123456789ajax(url, () =&gt; &#123; // 处理逻辑 ajax(url1, () =&gt; &#123; // 处理逻辑 ajax(url2, () =&gt; &#123; // 处理逻辑 &#125;) &#125;)&#125;) 这是几年前的方法，我们可以看出这样写简单、好实现，但是很容易写出回调地狱，如果嵌套很深，维护人员会很痛苦，此外它不能使用 try catch 捕获错误，不能直接 return。 事件监听 123456789func.on('done', func2);function func() &#123; setTimeout(function () &#123; // ... func.trigger('done'); &#125;, 1000);&#125; 这种方法可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。 发布订阅 1234567891011121314151617181920212223242526272829let fs = require('fs'); // fileSystem// 希望两次都完成 后 分别打印最终结果 在打印一次已经处理完毕// 发布 emit 订阅 on 一种一对多的关系 [fn,fn,fn]class Events &#123; constructor() &#123; this.stack = []; &#125; on(callback) &#123; this.stack.push(callback); &#125; emit() &#123; this.stack.forEach(callback =&gt; callback()) &#125;&#125;let events = new Events();let school = &#123;&#125;;events.on(function () &#123; if (Object.keys(school).length === 2) &#123; console.log(school) &#125;&#125;)events.on(function () &#123; console.log('当前获取完毕')&#125;)// 前端 服务端 好多原理都是基于发布订阅模式的fs.readFile('./javascript/promise/name.txt','utf8',function(err,data)&#123; // 5s school.name = data; events.emit();&#125;);fs.readFile('./javascript/promise/name.txt','utf8',function(err,data)&#123; // 3s school.age = data; events.emit();&#125;); 这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 2. promise 介绍中文网：https://es6.ruanyifeng.com/#docs/promise promise 本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。符合 promise A+ 规范, 按照这个规范可以自己实现一个 promise. promise 解决的问题: 回调嵌套,回调地狱 错误捕获不好处理错误 多个异步同步的问题 Promise.all promise 的几种状态 Pending—-Promise对象实例创建时候的初始状态 Fulfilled—-可以理解为成功的状态 Rejected—-可以理解为失败的状态 promise 一些特性： 只有等待态 才能变成 成功 / 失败 如果状态变化后不能在修改状态 promise中会存放两个变量， value 和 reasonpromise 的实例上，会有 then 方法 123456789101112// 默认是等待态，可以转化成成功或者失败，状态更改后不能再更改状态let promise = new Promise((resolve, reject) =&gt; &#123; resolve(123); reject(222);&#125;);console.log(promise)promise.then((value) =&gt; &#123; // fulfilled console.log('成功',value);&#125;,(reason) =&gt; &#123; // rejected console.log('失败',reason);&#125;); 3. promise 链式调用 每次调用返回的都是一个新的 promise 实例(这就是 then 可用链式调用的原因) 如果 then 中返回的是一个结果的话会把这个结果传递下一次 then 中的成功回调 如果 then 中出现异常,会走下一个 then 的失败回调 在 then 中使用了return，那么 return 的值会被Promise.resolve() 包装 then 中可以不传递参数，如果不传递会透到下一个 then 中 catch 会捕获到没有捕获的异常 finally 是 es9 的，不管成功或者失败都会走，不会中断运行，只是传递一个一定会执行的函数而已 123456789101112131415161718192021222324252627282930313233let Promise = require('./promise');let fs = require('fs');function read(url) &#123; return new Promise((resolve, reject)=&gt;&#123; fs.readFile(url, 'utf8', (err, data)=&gt;&#123; if(err) reject(err); resolve(data); &#125;) &#125;)&#125;read('./javascript/promise/name.txt') .then(data =&gt; &#123; throw new Error('出错了') &#125;) .then(data =&gt; &#123; console.log(data); &#125;,err=&gt;&#123; console.log('err', err); &#125;) .then(data =&gt; &#123; console.log(data); &#125;) // .catch(err =&gt; &#123; // console.log('catch'); // &#125;) .then(data =&gt; &#123; console.log(data); &#125;) // .finally(() =&gt; &#123; // console.log('finally'); // &#125;) 4. promise 方法 Promise.resolve() 将现有对象转为 Promise 对象 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Promise.all() 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例, 常用于无关联多接口请求处理 promise.all 执行时，若有一个reject, 边终止。 1const p = Promise.all([p1, p2, p3]); Promise.race() 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数 1const p = Promise.race([p1, p2, p3]); Promise.allsettled() es2020 新增方法，用来解决 promise.all 执行时，若有一个 reject, 边终止的情况，还是会返回执行结果 Promise.any() 只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态 5. 生成器 Generators/ yieldGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。 koa 1.0 在使用, koa2 废弃调了，使用 async + await 12345678910111213141516171819202122// 生成器 -&gt; 迭代器// 可以暂停执行 * 表示是一个生成器函数 yield 产出function* read() &#123; yield 1; yield 2; yield 3;&#125;// generator 返回的是生成器，生成器有一个 next 方法，调用这个方法，会返回一个对象，对象done,是否迭代完成，value 产出的结果let iterator = read();console.log(iterator);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());// 打印结果Object [Generator] &#123;&#125;&#123; value: 1, done: false &#125;&#123; value: 2, done: false &#125;&#123; value: 3, done: false &#125;&#123; value: undefined, done: true &#125; 这个地方要提下什么是类数组 类数组 =&gt; 可以被迭代 也可以用 Array.prototype.slice.call(arrayLike) 来将类数组转化成数组。 12345678910111213141516171819let arr = [...&#123; 0: 1, 1: 2, 2: 3, length: 3, [Symbol.iterator]: function () &#123; let index = 0; return &#123; next() &#123; return &#123; done: this.length != index, value: this[index++] &#125; &#125; &#125; &#125;&#125;];let arr = [...&#123; 0: 1, 1: 2, 2: 3, length: 3, [Symbol.iterator]: function* () &#123; let index = 0; while (index != this.length) &#123; yield this[index++]; &#125; &#125;&#125;]; 使用例子如下： 12345678910111213141516171819202122232425function* read() &#123; // try&#123; let content = yield fs.readFile('./name.txt', 'utf8'); let age = yield fs.readFile(content, 'utf8'); let a = yield age + 100; return a; // &#125;catch(err)&#123; // console.log(err); // &#125;&#125;let it = read();let &#123; value, done &#125; = it.next();value.then(function (data) &#123; let &#123; value, done &#125; = it.next(data); value.then(function (data) &#123; let &#123; value, done &#125; = it.next(data); value.then(function (data) &#123; let &#123; value, done &#125; = it.next(data); console.log(value); &#125;) &#125;)&#125;, function (err) &#123; it.throw(err);&#125;) 可以看出嵌套很深，老问题，我们常用 co 库来解决。 12345678910111213141516171819function co(it) &#123; return new Promise((resolve, reject) =&gt; &#123; // 异步迭代 next function next(data) &#123; // 如果碰到异步迭代，需要借助一个自执行函数来实现，保证第一次执行后调用下一次执行 let &#123; value, done &#125; = it.next(data); if (!done) &#123; Promise.resolve(value).then(data =&gt; &#123; next(data) &#125;, reject); &#125; else &#123; resolve(value); &#125; &#125; next(); &#125;);&#125;co(read()).then(data =&gt; &#123; console.log(data);&#125;); 6. 终极方法 async + awaitasync + await 可以理解为 generator + co 语法糖 12345678910111213141516171819202122let fs = require('fs')function read(file) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(file, 'utf8', function(err, data) &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;function readAll() &#123; read1() read2() // 这个函数同步执行&#125;async function read1() &#123; let r = await read('1.txt','utf8') console.log(r)&#125;async function read2() &#123; let r = await read('2.txt','utf8') console.log(r)&#125;readAll() // 2.txt 3.txt 所以归纳一下 js 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await 7. 如何自己实现一个 promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162function resolvePromise(promise2, x, resolve, reject) &#123; // 判断x的类型 来处理 promise2 是成功还是失败 if (promise2 === x) &#123; return reject(new TypeError('TypeError: Chaining cycle detected for promise #&lt;Promise&gt;')); &#125; let called; if (typeof x === 'function' || (typeof x === 'object' &amp;&amp; x != null)) &#123; try &#123; let then = x.then; // then 可能是getter object.defineProperty if (typeof then === 'function') &#123; // &#123;then:null&#125; 就认为他是一个promise then.call(x, y =&gt; &#123; // 让当前的promise 执行，不用多次取 then 方法了 if (called) return; // 1) called = true; resolvePromise(promise2, y, resolve, reject); &#125;, r =&gt; &#123; if (called) return; // 2) called = true; reject(r); &#125;) &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called) return; // 3) 为了辨别这个promise 不能调用多次 called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;class Promise &#123; constructor(executor) &#123; this.status = 'pending'; // 默认当前状态是等待态 this.value; this.reason; this.onResolvedCallbacks = []; // 存储成功的所有的回调 只有pending的时候才存储 this.onRejectedCallbacks = []; // 存储所有失败的 let resolve = (value) =&gt; &#123; if (this.status === 'pending') &#123; // 只有等待态的时候才能更改数据 this.status = 'fulfilled'; this.value = value; this.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; // 默认会调用执行函数 try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125; then(onFulfilled, onRejected) &#123; // onFulfilled onRejected 是 可选参数 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val =&gt; val; onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125; let promise2; // 可以不停的调用then方法,必须返还一个新的promise // 异步的特点 等待当前主栈代码都执行后才执行 promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.status === 'fulfilled') &#123; setTimeout(() =&gt; &#123; // 为了保证Promise2 存在 try &#123; // 需要对 then 的成功的回调 和失败的回调 取到他的返回结果， 如果是普通值就让promise2成功 let x = onFulfilled(this.value); // 对 x 的类型做 判断，常量可以直接抛出来，但是如果是promise 需要采用当前promise的状态 // x 如果是普通值，直接调用Promise2 的resolve // x 如果是promsie, 让x这个promise执行 x.then resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === 'rejected') &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === 'pending') &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;) &#125; &#125;) return promise2; &#125; catch(rejectFunc) &#123; // 用来捕获错误 ， 语法糖 return this.then(null, rejectFunc); &#125;&#125;// 暴露一个方法， 这个方法需要返回一个对象，对象上需要有 promise resolve reject 三个属性// 希望测试一下这个库是否符合我们的promise A+规范 https://promisesaplus.com/// promises-aplus-tests 文件名Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;Promise.resolve = function (value) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(value); &#125;)&#125;Promise.reject = function (value) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(value); &#125;)&#125;Promise.prototype.finally = function (callback) &#123; return this.then((data) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; data); // return new Promise((resolve,reject)=&gt;&#123; // resolve(callback()); // 如果callback是一个函数返回promise 就等待这个promise执行完毕 // &#125;).then(()=&gt;data); // callback(); // return data; &#125;, (err) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err &#125;); // koa 原理 // throw err; &#125;);&#125;;module.exports = Promise; 上面是我简单实现的 promise 如何测试该 promise 是否合格，可参考promise test 8. 其他工具 bbluebird 第三方库 实现 promise 化 123456// node 中已经借鉴了，所有的异步方法参数第一个都是errlet read = bluebird.promisify(fs.readFile);read('./javascript/promise/name.txt', 'utf8', function (err, data) &#123; console.log(data);&#125;); 下面自己实现一个 promisefy 123456789101112131415const promisify = (fn) =&gt; (...args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; //fs.readFile(path.resolve(__dirname,'1.txt'),'utf8',) fn(...args, (err, data) =&gt; &#123; if (err) &#123; return reject(err) &#125; resolve(data); &#125;) &#125;)&#125;const promisifyAll = (obj) =&gt; &#123; for (let key in obj) &#123; obj[key] = promisify(obj[key]); &#125;&#125; mz 第三方包 他里面把所有的 node 模块, 都进行了包装promise 1234let fs = require('mz/fs');fs.readFile('name.txt', 'utf8').then(data =&gt; &#123;&#125;);]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
        <tag>promise</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Less 的一些理解]]></title>
    <url>%2F2020%2F03%2F19%2Fless%2F</url>
    <content type="text"><![CDATA[最近项目用到 less 来做 css 预处理器，之前公司项目是用的 sass，所以抽空针对 less，重新了解了一番。 1. Less 的由来[Less 中文官方网站]：http://lesscss.cn/ 官网：http://lesscss.org/ 在 Web 发展的这几年，有了 webpack 来做构建，所以为了让 CSS 富有逻辑性，短板(在语法更新时，每当新属性提出，浏览器的兼容又会马上变成绊脚石)不那么严重，涌现出了一些神奇的预处理语言。 它们让 CSS 彻底变成一门可以使用变量、循环、继承、自定义方法等多种特性的标记语言，逻辑性得以大大增强。 其中 常见的有三种：Sass、Less 、Stylus 。 Sass 诞生于 2007 年，Ruby 编写，其语法功能都十分全面，可以说 它完全把 CSS 变成了一门编程语言。另外 在国内外都很受欢迎，并-且它的项目团队很是强大 ，是一款十分优秀的预处理语言。 Stylus 诞生于 2010 年，来自 Node.js 社区，语法功能也和 Sass 不相伯仲，是一门十分独特的创新型语言。 Less 诞生于 2009 年，受 Sass 的影响创建的一个开源项目。 它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充（引用于官网）。 如何选择？ 这个问题其实不重要，主要看你们项目和团队的情况，如果你们团队成员都喜欢用 less, 那便选择它就行啦。 2. 如何使用常见的有两种方式： 在页面中 引入 Less.js，可在官网下载，或使用 CDN 1&lt;script src="//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.3/less.min.js"&gt;&lt;/script&gt; 在命令行 使用 npm 安装 1# npm install -g less 使用命令 1# lessc styles.less &gt; styles.css 如果你使用了 webpack，那么你需要配合 less-loader 进行处理(这个网上很多文章有介绍) 3. Less 常用功能特性3.1 变量我们常常在 CSS 中 看到同一个值重复多次，这样难易于代码维护。 值变量 1234567891011121314// 以 @ 开头 定义变量@color: #999;@bgColor: red;@width: 50%;#wrap &#123; color: @color; width: @width;&#125;/* 生成后的 CSS */#wrap &#123; color: #999; width: 50%;&#125; 通常我们在实际项目中会把变量定义存到到一个文件，方便维护。 选择器变量 12345678910111213141516171819202122232425/* Less */@mySelector: #wrap;@Wrap: wrap;@&#123;mySelector&#125; &#123; // 变量名 必须使用大括号包裹 color: #999; width: 50%;&#125;.@&#123;Wrap&#125; &#123; color:#ccc;&#125;#@&#123;Wrap&#125; &#123; color:#666;&#125;/* 生成的 CSS */#wrap&#123; color: #999; width: 50%;&#125;.wrap&#123; color:#ccc;&#125;#wrap&#123; color:#666;&#125; 属性变量 1234567891011/* Less */@borderStyle: border-style;@Soild: solid;#wrap&#123; @&#123;borderStyle&#125;: @Soild; // 变量名 必须使用大括号包裹&#125;/* 生成的 CSS */#wrap&#123; border-style: solid;&#125; url 变量 12345678910/* Less */@images: "../img"; // 需要加引号body &#123; background: url("@&#123;images&#125;/dog.png");//变量名 必须使用大括号包裹&#125;/* 生成的 CSS */body &#123; background: url("../img/dog.png");&#125; 声明变量 1234567891011121314151617181920212223/* Less */@background: &#123;background:red;&#125;;#main&#123; @background();&#125;@Rules:&#123; width: 200px; height: 200px; border: solid 1px red;&#125;;#con&#123; @Rules();&#125;/* 生成的 CSS */#main&#123; background:red;&#125;#con&#123; width: 200px; height: 200px; border: solid 1px red;&#125; 变量运算 12345678910111213141516171819/* Less */@width: 300px;@color: #222;#wrap&#123; width: @width-20; height: @width- 20 * 5; margin:(@width - 20) * 5; color: @color * 2; background-color: @color + #111;&#125;/* 生成的 CSS */#wrap&#123; width: 280px; height: 200px; margin: 1400px; color: #444; background-color: #333;&#125; 变量作用域 1234567891011121314151617181920212223242526/* Less */@var: @a;@a: 100%;#wrap &#123; width: @var; @a: 9%;&#125;/* 生成的 CSS */#wrap &#123; width: 9%;&#125;// ================================/* Less */@fnord: "I am fnord.";@var: "fnord";#wrap::after&#123; content: @@var; //将@var替换为其值 content:@fnord;&#125;/* 生成的 CSS */#wrap::after&#123; content: "I am fnord.";&#125; 3.2 嵌套 &amp; 使用 1234567891011121314151617181920212223/* Less */#header &#123; &amp;:after &#123; content:"Less is more!"; &#125; .title &#123; font-weight: bold; &#125; &amp;_content &#123; margin:20px; &#125;&#125;/* 生成的 CSS */#header::after &#123; content:"Less is more!";&#125;#header .title &#123; font-weight:bold;&#125;#header_content &#123; margin:20px;&#125; 媒体查询 1234567891011121314151617181920212223/* Less */#main&#123; @media screen&#123; @media (max-width: 768px)&#123; width:100px; &#125; &#125; @media tv &#123; width:2000px; &#125;&#125;/* 生成的 CSS */@media screen and (max-width:768px)&#123; #main&#123; width:100px; &#125;&#125;@media tv&#123; #main&#123; width:2000px; &#125;&#125; 3.3 混合方法 无参数方法 123456789101112/* Less */.card &#123; // 等价于 .card() background: #fff;&#125;#wrap &#123; .card; // 等价于 .card();&#125;/* 生成的 CSS */#wrap &#123; background: #fff;&#125; 默认参数方法 12345678910111213141516171819202122232425262728/* Less */.border(@a:10px,@b:50px,@c:30px,@color:#000)&#123; border:solid 1px @color; box-shadow: @arguments; // 指代的是 全部参数&#125;#main&#123; .border(0px,5px,30px,red);&#125;#wrap&#123; .border(0px);&#125;#content&#123; .border;//等价于 .border()&#125;/* 生成的 CSS */#main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red;&#125;#wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000;&#125;#content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000;&#125; 条件筛选 when 1234567891011121314151617181920212223242526272829/* Less */#card&#123; // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999)&#123; border:@style @color @width; &#125; // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222)&#123; background:@color; &#125; // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px)&#123; font-size: @size; &#125;&#125;#main&#123; #card&gt;.border(200px,#999,solid); #card .background(#111); #card &gt; .font(40px);&#125;/* 生成后的 CSS */#main&#123; border:solid #999 200px; background:#111; font-size:40px;&#125; 数量不定的参数 1234567891011121314151617/* Less */.boxShadow(...)&#123; box-shadow: @arguments;&#125;.textShadow(@a,...)&#123; text-shadow: @arguments;&#125;#main&#123; .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red);&#125;/* 生成后的 CSS */#main&#123; box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red;&#125; !important 使用 1234567891011121314/* Less */.border&#123; border: solid 1px red; margin: 50px;&#125;#main&#123; .border() !important;&#125;/* 生成后的 CSS */#main &#123; border: solid 1px red !important; margin: 50px !important;&#125; 属性拼接方法 +_ 代表的是 空格；+ 代表的是 逗号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Less */.boxShadow() &#123; box-shadow+: inset 0 0 10px #555;&#125;.main &#123; .boxShadow(); box-shadow+: 0 0 20px black;&#125;/* 生成后的 CSS */.main &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black;&#125;// ===================================/* Less */.Animation() &#123; transform+_: scale(2);&#125;.main &#123; .Animation(); transform+_: rotate(15deg);&#125;/* 生成的 CSS */.main &#123; transform: scale(2) rotate(15deg);&#125;// =====================================/* Less */.average(@x, @y) &#123; @average: ((@x + @y) / 2);&#125;div &#123; .average(16px, 50px); // 调用 方法 padding: @average; // 使用返回值&#125;/* 生成的 CSS */div &#123; padding: 33px;&#125; 3.4 继承 extend 123456789101112131415161718192021/* Less */.animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125;&#125;#main&#123; &amp;:extend(.animation);&#125;#con&#123; &amp;:extend(.animation .hide);&#125;/* 生成后的 CSS */.animation, #main&#123; transition: all .3s ease-out;&#125;.animation .hide , #con&#123; transform:scale(0);&#125; all 全局继承 123456789101112131415161718/* Less */#main &#123; width: 200px;&#125;#main &#123; &amp;:after &#123; content:"Less is good!"; &#125;&#125;#wrap:extend(#main all) &#123;&#125;/* 生成的 CSS */#main,#wrap &#123; width: 200px;&#125;#main:after, #wrap:after &#123; content: "Less is good!";&#125; 3.5 导入 @import 3.6 函数123isnumber(#ff0); // falsesaturate(hsl(90, 80%, 50%), 20%) // #80ff00 // hsl(90, 100%, 50%) 查看更多函数链接]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我对 ESlint 的理解]]></title>
    <url>%2F2020%2F03%2F12%2Feslint%2F</url>
    <content type="text"><![CDATA[1. eslint 介绍eslint 属于一种 QA 工具，是一个 ECMAScript/JavaScript 语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 eslint 完全可配置，它的目标是提供一个插件化的 javascript 代码检测工具。这意味着您可以关闭每个规则，只能使用基本语法验证，或者混合并匹配捆绑的规则和自定义规则，使 eslint 完美的适用于当前项目。 [ESLint 中文官方网站]：http://eslint.cn/ 官网：https://eslint.org/ 2. lint 工具发展过程在 JavaScript 20 多年的发展历程中，也出现过许许多多的 lint 工具，下面就来介绍下主流的三款 lint 工具。 JSLint JSLint 可以说是最早出现的 JavaScript 的 lint 工具，由 Douglas Crockford (《JavaScript 语言精粹》作者) 开发。JSLint 的所有规则都是由 Douglas 自己定义的，可以说这是一个极具 Douglas 个人风格的 lint 工具，如果你要使用它，就必须接受它所有规则。值得称赞的是，JSLint 依然在更新，而且也提供了 node 版本：node-jslint。 JSHint 由于 JSLint 让很多人无法忍受它的规则，感觉受到了压迫，所以 Anton Kovalyov 基于 JSLint 开发了 JSHint。JSHint 在 JSLint 的基础上提供了丰富的配置项，给了开发者极大的自由，JSHint 一开始就保持着开源软件的风格，由社区进行驱动，发展十分迅速。早起 jQuery 也是使用 JSHint 进行代码检查的，不过现在已经转移到 ESLint 了。 ESLint ESLint 由 Nicholas C. Zakas (《JavaScript 高级程序设计》作者) 于2013年6月创建，它的出现因为 Zakas 想使用 JSHint 添加一条自定义的规则，但是发现 JSHint 不支持，于是自己开发了一个。 ESLint 号称下一代的 JS Linter 工具，它的灵感来源于 PHP Linter，将源代码解析成 AST，然后检测 AST 来判断代码是否符合规则。ESLint 使用 esprima 将源代码解析成 AST，然后你就可以使用任意规则来检测 AST 是否符合预期，这也是 ESLint 高可扩展性的原因。 但是，那个时候 ESLint 并没有大火，因为需要将源代码转成 AST，运行速度上输给了 JSHint ，并且 JSHint 当时已经有完善的生态（编辑器的支持）。真正让 ESLint 大火是因为 ES6 的出现。 ES6 发布后，因为新增了很多语法，JSHint 短期内无法提供支持，而 ESLint 只需要有合适的解析器就能够进行 lint 检查。这时 babel 为 ESLint 提供了支持，开发了 babel-eslint，让 ESLint 成为最快支持 ES6 语法的 lint 工具。 在 2016 年，ESLint 整合了与它同时诞生的另一个 lint 工具：JSCS，因为它与 ESLint 具有异曲同工之妙，都是通过生成 AST 的方式进行规则检测。 3. lint 工具优点 避免低级 bug，找出可能发生的语法错误 使用未声明变量、修改 const 变量 提示删除多余的代码 确保代码遵循最佳实践 可参考 airbnb style、javascript standard, AlloyTeam eslint-config-alloy 统一团队的代码风格 加不加分号、使用 tab 还是空格 4. 如何使用4.1 安装如何在项目中引入 eslint: 12345678# 全局安装 ESLint$ npm install -g eslint# 进入项目$ cd ~/workspace/project# 初始化 ESLint 配置$ eslint --init 在使用 eslint –init 后，会出现很多用户配置项，具体可以参考：eslint cli 部分的源码。 经过一系列一问一答的环节后，你会发现在你文件夹的根目录生成了一个 .eslintrc.js 文件。 4.2 配置ESLint 一共有两种配置方式： 使用注释把 lint 规则直接嵌入到源代码中 12345// ~/workspace/project/src/test.js/* eslint eqeqeq: "error" */const num = 1num == '1' 这时运行 eslint src/test.js 会报错误 1Expected '===' and instead saw '==' 当然我们一般使用注释是为了临时禁止某些严格的 lint 规则出现的警告 12345678910111213/* eslint-disable */alert('该注释放在文件顶部，整个文件都不会出现 lint 警告')/* eslint-enable */alert('重新启用 lint 告警')/* eslint-disable */alert('只禁止某一个或多个规则')/* eslint-disable-next-line */alert('当前行禁止 lint 警告')alert('当前行禁止 lint 警告') // eslint-disable-line 使用配置文件进行 lint 规则配置 在初始化过程中，有一个选项就是使用什么文件类型进行 lint 配置（What format do you want your config file to be in?） 官方一共提供了三个选项： JavaScript (eslintrc.js) YAML (eslintrc.yaml) JSON (eslintrc.json) 翻阅 ESLint 源码 可以看到，其配置文件的优先级如下： 123456789// 优先级按定义从上往下依次降低const configFilenames = [ ".eslintrc.js", ".eslintrc.yaml", ".eslintrc.yml", ".eslintrc.json", ".eslintrc", "package.json"]; 4.3 项目级与目录级的配置我们有如下目录结构，此时在根目录运行 ESLint，那么我们将得到两个配置文件 .eslintrc.js（项目级配置） 和 src/.eslintrc.js（目录级配置），这两个配置文件会进行合并，但是 src/.eslintrc.js 具有更高的优先级 123456# project 项目文件目录.├── src│ ├── .eslintrc.js├── .eslintrc.js... 但是，我们只要在 src/.eslintrc.js 中配置 “root”: true，那么 ESLint 就会认为 src 目录为根目录，不再向上查找配置。 4.4 配置参数 解析器配置 123456789101112131415161718&#123; // 解析器类型 // espima(默认), babel-eslint, @typescript-eslint/parse "parser": "esprima", // 解析器配置参数 "parseOptions": &#123; // 代码类型：script(默认), module "sourceType": "script", // es 版本号，默认为 5，也可以是用年份，比如 2015 (同 6) "ecamVersion": 6, // es 特性配置 "ecmaFeatures": &#123; "globalReturn": true, // 允许在全局作用域下使用 return 语句 "impliedStrict": true, // 启用全局 strict mode "jsx": true // 启用 JSX &#125;, &#125;&#125; 对于 @typescript-eslint/parse 这个解析器，主要是为了替代之前存在的 TSLint，TS 团队因为 ESLint 生态的繁荣，且 ESLint 具有更多的配置项，不得不抛弃 TSLint 转而实现一个 ESLint 的解析器。同时，该解析器拥有 @typescript-eslint/parse 不同配置 1234567891011&#123; "parserOptions": &#123; "ecmaFeatures": &#123; "jsx": true &#125;, "useJSXTextNode": true, "project": "./tsconfig.json", "tsconfigRootDir": "../../", "extraFileExtensions": [".vue"] &#125;&#125; 环境与全局变量 ESLint 会检测未声明的变量，并发出警告，但是有些变量是我们引入的库声明的，这里就需要提前在配置中声明。 123456&#123; "globals": &#123; // 声明 jQuery 对象为全局变量 "$": false // true表示该变量为 writeable，而 false 表示 readonly &#125;&#125; 在 globals 中一个个的进行声明未免有点繁琐，这个时候就需要使用到 env ，这是对一个环境定义的一组全局变量的预设（类似于 babel 的 presets）。 1234567&#123; "env": &#123; "amd": true, "commonjs": true, "jquery": true &#125;&#125; 可选的环境很多，预设值都在 这个文件 中进行定义，查看源码可以发现，其预设变量都引用自 globals 包。 4.5 规则配置ESLint 附带有 大量的规则，你可以在配置文件的 rules 属性中配置你想要的规则。每一条规则接受一个参数，参数的值如下： “off” 或 0：关闭规则 “warn” 或 1：开启规则，warn 级别的错误 (不会导致程序退出) “error” 或 2：开启规则，error级别的错误(当被触发的时候，程序会退出) 但是，事情往往没有我们想象中那么简单，ESLint 的规则不仅只有关闭和开启这么简单，每一条规则还有自己的配置项。如果需要对某个规则进行配置，就需要使用数组形式的参数, 如下 quotes 规则设置 1234567891011121314&#123; "rules": &#123; // 使用数组形式，对规则进行配置 // 第一个参数为是否启用规则 // 后面的参数才是规则的配置项 "quotes": [ "error", "single", &#123; "avoidEscape": true &#125; ] &#125;&#125; 按照如上规则 12345// badlet str = "test 'ESLint' rule"// goodlet str = 'test "ESLint" rule' 5 扩展扩展就是直接使用别人已经写好的 lint 规则，方便快捷。扩展一般支持三种类型： 1234567&#123; "extends": [ "eslint:recommended", "plugin:react/recommended", "eslint-config-standard", ]&#125; eslint: 开头的是 ESLint 官方的扩展，一共有两个：eslint:recommended 、eslint:all。 plugin: 开头的是扩展是插件类型，也可以直接在 plugins 属性中进行设置。 最后一种扩展来自 npm 包，官方规定 npm 包的扩展必须以 eslint-config- 开头，使用时可以省略这个头，上面案例中 eslint-config-standard 可以直接简写成 standard 如果你觉得自己的配置十分满意，也可以将自己的 lint 配置发布到 npm 包，只要将包名命名为 eslint-config-xxx 即可，同时，需要在 package.json 的 peerDependencies 字段中声明你依赖的 ESLint 的版本号。 6. 插件虽然官方提供了上百种的规则可供选择，但是这还不够，因为官方的规则只能检查标准的 JavaScript 语法，如果你写的是 JSX 或者 Vue 单文件组件，ESLint 的规则就开始束手无策了。 这个时候就需要安装 ESLint 的插件，来定制一些特定的规则进行检查。ESLint 的插件与扩展一样有固定的命名格式，以 eslint-plugin- 开头，使用的时候也可以省略这个头。 1# npm install --save-dev eslint-plugin-vue eslint-plugin-react 配置如下： 123456&#123; "plugins": [ "react", // eslint-plugin-react "vue", // eslint-plugin-vue ]&#125; 或者是在扩展中引入插件，前面有提到 plugin: 开头的是扩展是进行插件的加载。 12345&#123; "extends": [ "plugin:react/recommended", ]&#125; eslint-plugin-react 源码 可以看到： 1234567891011121314151617module.exports = &#123; // 自定义的 rule rules: allRules, // 可用的扩展 configs: &#123; // plugin:react/recommended recomended: &#123; plugins: [ 'react' ] rules: &#123;...&#125; &#125;, // plugin:react/all all: &#123; plugins: [ 'react' ] rules: &#123;...&#125; &#125; &#125;&#125; 配置名是插件配置的 configs 属性定义的，这里的配置其实就是 ESLint 的扩展，通过这种方式即可以加载插件，又可以加载扩展 6.1 开发插件ESLint 官方为了方便开发者，提供了 Yeoman 的模板（generator-eslint） 123456789# 安装模块npm install -g yo generator-eslint# 创建目录mkdir eslint-plugin-democd eslint-plugin-demo# 创建模板yo eslint:plugin 创建好项目之后，就可以开始创建一条规则了，幸运的是 generator-eslint 除了能够生成插件的模板代码外，还具有创建规则的模板代码。 12# 生成模板yo eslint:rule 打开 lib/rules/rule-demo.js ，可以看到默认的模板代码如下 12345678910111213141516module.exports = &#123; meta: &#123; docs: &#123; description: "disable console", category: "Fill me in", recommended: false &#125;, schema: [] &#125;, create: function (context) &#123; // variables should be defined here return &#123; // give me methods &#125;; &#125;&#125;; 详细的参数介绍可以查看官方文档 具体示例可以参考 博文 7. 忽略文件我们的整个项目中，有一些文件是不需要 eslint 进行检查，我们可以用到忽略文件。 在我们的工程目录中新建一个文件，命名为 “.eslintignore” ，eslint 会自动识别这个文件 您可以通过提供不同文件的路径来覆盖此行为。–ignore-path 12eslint --ignore-path tmp/.eslintignore file.jseslint --ignore-path .gitignore file.js –no-ignore 禁用从文件的排除 .eslintignore ， –ignore-path 和 –ignore-pattern 1eslint --no-ignore file.js 比如，你已经在忽略文件 .eslintignore 中忽略了某文件，但是你又在命令行中执行了 eslint 该文件，则为警告提示，您可以使用 –no-ignore 忽略使用忽略规则。 在 package.json 中使用 eslintIgnore 如果 .eslintignore 未找到文件并且未指定备用文件，ESLint 将在 package.json 中查找 eslintIgnore 密钥以检查要忽略的文件。 123456789101112&#123; "name": "mypackage", "version": "0.0.1", "eslintConfig": &#123; "env": &#123; "browser": true, "node": true &#125; &#125;, "eslintIgnore": ["hello.js", "world.js"] ...&#125; 8. 工程应用实际工程中，我们一般会搭配一些优秀的插件和第三方库构建工作流。 搭配使用 Prettier 统一代码风格 npm 安装 husky 和 lint-staged，配置 git 检查工作流 下面是 我项目中用到的一些配置 12345678910111213141516171819202122232425262728// package.json&#123; &#123; "name": "...", "version": "...", "scripts": &#123; "lint:style": "stylelint \"src/**/*.scss\" --syntax scss", "lint:style-fix": "stylelint \"src/**/*.scss\" --syntax scss --fix", "lint": "eslint src --ext .ts,.tsx", "lint-fix": "eslint src --fix --ext .ts,.tsx", ... &#125;, "husky": &#123; "hooks": &#123; "pre-commit": "lint-staged" &#125; &#125;, "lint-staged": &#123; "src/**/*.&#123;ts,tsx&#125;": [ "eslint --fix", "git add" ], "src/**/*.scss": [ "stylelint --config=.stylelintrc --fix", "git add" ] &#125;,&#125; 12345678910111213141516171819202122232425262728// .eslintrc.json&#123; "extends": [ "plugin:@typescript-eslint/recommended", "react-app", "prettier/@typescript-eslint", "plugin:prettier/recommended" ], "plugins": ["react", "@typescript-eslint", "prettier"], "env": &#123; "browser": true, "jasmine": true, "jest": true &#125;, "rules": &#123; "prettier/prettier": ["error", &#123; "singleQuote": true, "endOfLine": "auto" &#125;], "@typescript-eslint/interface-name-prefix": ["error", "always"], "@typescript-eslint/explicit-member-accessibility": 0, "@typescript-eslint/explicit-function-return-type": 0, "@typescript-eslint/no-angle-bracket-type-assertion": 0, "@typescript-eslint/array-type": 0, "jsx-a11y/anchor-is-valid": 0 &#125;, "parser": "@typescript-eslint/parser"&#125;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 一些工具泛型的使用小结]]></title>
    <url>%2F2019%2F07%2F26%2FTS%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在 TypeScript（下面统一简称 TS）中默认内置了很多工具泛型，能够合理灵活的使用这些工具，可以使我们的类型定义更加灵活，严谨。最近用 TS 重构了一版工程，下面是我根据自己的理解以及日常使用做的一些总结。 这些泛型定义在 node_modules/typescript/lib/lib.es5.d.ts 文件中，大概是从 1400 多行开始。所以，有兴趣也可以研究一下它们的源码实现，很有意思。 1. PartialPartial 作用是将传入的属性变为可选项。 首先我们需要理解两个关键字 keyof 和 in, keyof 可以用来取得一个对象接口的所有 key 值。例如： 12345interface Foo &#123; name: string; age: number&#125;type T = keyof Foo // -&gt; "name" | "age" 而 in 则可以遍历枚举类型, 例如： 1234type Keys = "a" | "b"type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any &#125; keyof 产生联合类型, in 则可以遍历枚举类型, 所以他们经常一起使用 在 TS 中的源码实现： 123type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;; 上面语句的意思是 keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值。结合中间的 ? 使属性可选。 2. RequiredRequired 作用是将传入的属性变为必选项。 在 TS 中的源码实现： 123type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P];&#125;; 我们发现一个有意思的用法 -?, 这里很好理解就是将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个 +? , 这个含义自然与 -? 之前相反, 它是用来把属性变成可选项的。 3. ReadonlyReadonly 作用是将传入的属性变为只读选项。 在 TS 中的源码实现： 123type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;; 4. PickPick 作用是从 T 中将所有的 K 取出来，并生成一个新的类型。 在 TS 中的源码实现： 123type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;; 5. RecordRecord 作用是将 K 中所有的属性的值转化为 T 类型。 在 TS 中的源码实现： 123type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T;&#125;; 6. ExcludeExclude 作用是从 T 中排除掉所有包含的 U 属性。 在 TS 中的源码实现： 1type Exclude&lt;T, U&gt; = T extends U ? never : T; 7. ExtractExtract 作用正好和上面的 Exclude 相反。而是从 T 中提取出所有包含的 U 属性值。 在 TS 中的源码实现： 1type Extract&lt;T, U&gt; = T extends U ? T : never; 8. OmitOmit 作用是用来忽略 T 中的 K 属性。 在 TS 中的源码实现： 1type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; 示例： 12// 使用type Foo = Omit&lt;&#123;name: string, age: number&#125;, 'name'&gt; // -&gt; &#123; age: number &#125; 9. NonNullableNonNullable 作用是去除 T 中包含的 null 或者 undefined。 在 TS 中的源码实现： 1type NonNullable&lt;T&gt; = T extends null | undefined ? never : T; 示例： 1234type TFoo = 1 | null | undefinedlet foo: NonNullable&lt;TFoo&gt; = 1 // 正确foo = null // 错误，因为这个值已经被去除 10. ParametersParameters 作用是用来获取一个函数的参数类型，而且返回的是只能包含一组类型的数组。 在 TS 中的源码实现： 1type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never; 示例： 123456type Func = (user: string) =&gt; voidtype Param = Parameters&lt;Func&gt;let p: Param = ['1'] // 正确p = ['1', '2'] // 错误，只能包含一个字符串类型值 通过上面的示例可以看到通过 Parameters 获取到了 Func 的参数类型，并返回的是数组形式：[string]。因此，变量p的赋值就只能是包含一个字符串类型值的数组。 11. ConstructorParametersConstructorParameters 作用是用来获取一个类的构造函数参数类型，并以数组的形式返回。 在 TS 中的源码实现： 1type ConstructorParameters&lt;T extends new (...args: any) =&gt; any&gt; = T extends new (...args: infer P) =&gt; any ? P : never; 示例： 123456789// 类 Foo 的构造函数有两个参数，第一个为 string 类型，第二个为 number 类型。class Foo &#123; constructor(x: string, y: number)&#123; console.log(x, y) &#125;&#125;// 在使用 ConstructorParameters 处理之后，获取到的是一个类型数组。而且第一个值必须为 string 类型，第二个值必须为 number 类型。const foo: ConstructorParameters&lt;typeof Foo&gt; = ['1', 2] 12. ReturnTypeReturnType 作用是用来得到一个函数的返回值类型。 在阅读源码之前我们需要了解一下 infer 这个关键字, 在条件类型语句中, 我们可以用 infer 声明一个类型变量并且对它进行使用, 我们可以用它获取函数的返回类型。 在 TS 中的源码实现： 1type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any; 其实这里的 infer R 就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用. 示例： 1234// 用 ReturnType 获取到 Func 的返回值类型为 string，所以，foo 也就只能被赋值为字符串了type Func = (value: number) =&gt; stringconst foo: ReturnType&lt;Func&gt; = '1' 13. InstanceTypeInstanceType 作用是获取一个类的实例类型，可以用获取到的实例类型来约束一个变量的赋值必须和类的成员类型完全一样才可以。 在 TS 中的源码实现： 1type InstanceType&lt;T extends new (...args: any) =&gt; any&gt; = T extends new (...args: any) =&gt; infer R ? R : any; 示例： 123456789101112131415161718192021// 定义的类 Foo 中有一个字符串类型的 x，一个数字类型的 y，一个参数为字符串类型的方法 sayclass Foo &#123; public x = '1' public y = 2 public say = (value: string) =&gt; &#123; console.log(value) &#125;&#125;// 我们用 InstanceType 获取类 Foo 的实例类型，用来它约束变量 foo。那么，接下来给foo赋值时就必须完全符合 Foo 的成员类型才可以const foo: InstanceType&lt;typeof Foo&gt; = &#123; x: '1', y: 2, say: (value: string) =&gt; &#123; console.log(value) &#125;&#125;// 假设你将变量foo中的x值赋值为数字 1，就肯定会收到类型检查错误了：// Type 'number' is not assignable to type 'string'. 14. 自定义类型别名（非内置类型定义）下面是一些可能会经常用到，但是 TS 没有内置的一些类型别名： DeepReadonly DeepReadonly 用来深度遍历 T，并将其所有属性变成只读类型。 1type DeepReadonly&lt;T&gt; = &#123; readonly [P in keyof T]: DeepReadonly&lt;T[P]&gt; &#125; ConvertNumberToString ConvertNumberToString 用来将 number 转换为 string 类型。 123type ConvertNumberToString&lt;T&gt; = &#123; [K in keyof T]: T[K] extends string ? string : T[K]&#125; ValueOf ValueOf与keyof相对应。取出指定类型的所有 value。 1type ValueOf&lt;T&gt; = T[keyof T] Mutable Mutable 用来将 T 的所有属性的 readonly 移除。 123type Mutable&lt;T&gt; = &#123; -readonly [P in keyof T]: T[P]&#125; 其实还有对 + 和 -, 这里要说的不是变量的之间的进行加减而是对 readonly 进行加减。 PowerPartial 内置的 Partial 有个局限性，就是只支持处理第一层的属性，如果是嵌套多层的就没有效果了，不过可以如下自定义： 123456type PowerPartial&lt;T&gt; = &#123; // 如果是 object，则递归类型 [U in keyof T]?: T[U] extends object ? PowerPartial&lt;T[U]&gt; : T[U]&#125;; 学习链接： 英文版： https://basarat.gitbooks.io/typescript/content/# 中文版： https://jkchao.github.io/typescript-book-chinese/#why 官网： http://www.typescriptlang.org/docs/home.html https://juejin.im/post/5c2f87ce5188252593122c98#heading-5 https://github.com/chenxiaochun/blog/issues/67 https://zhuanlan.zhihu.com/p/40311981]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins pipeline 介绍]]></title>
    <url>%2F2019%2F06%2F15%2Fjenkins%2F</url>
    <content type="text"><![CDATA[pipeline 语法参考 https://jenkins.io/doc/book/pipeline/syntax/ 1. jenkinsfile 骨架 12345678910111213141516171819202122232425262728293031323334353637383940pipeline &#123; agent &#123; // 构建的节点 &#125; environment &#123; // 构建时注入的环境变量 &#125; parameters &#123; // 参数化构建 &#125; triggers &#123; // 构建触发器 &#125; // 构建阶段 stages &#123; stage('测试') &#123; steps &#123; // 测试阶段步骤 &#125; &#125; stage('构建') &#123; steps &#123; &#125; &#125; &#125; // 构建后回调，可以在success和failure中通知开发 post &#123; success &#123; &#125; failure &#123; &#125; &#125;&#125; 2. agentagent，定义构建的节点，也可以在 stage 中指定。默认 none，如果我们在 jenkins 上配置了一个 mac 节点，app 在 mac 节点上构建，那么我们可以如下声明： 12345agent &#123; node &#123; label: 'mac' &#125;&#125; 3. environment可以在 environment 中注入构建时的环境变量。如我们构建时使用指定路径的 nodejs： 123environment &#123; PATH = "$&#123;PATH&#125;:$&#123;HOME&#125;/.nvm/versions/node/v8.11.1/bin"&#125; 除了可以在 environment 中声明环境变量外，还可以在 groovy 脚本中添加或修改。 123script &#123; env.DOCKER_HOST='tcp://192.168.71.86:2376'&#125; 4. parameters有时候我们需要参数化构建，如选择构建的环境，也可以通过 jenkinsfile 定义。下面示例提供了两个选择框，可以选择部署的环境和部署类型。需要注意的是，选择框的第一个为默认值。 12345parameters &#123; choice(name: 'DEPLOY_ENV', choices: ['test', 'demo', 'production'], description: '选择部署环境'); choice(name: 'DEPLOY_TYPE', choices: ['部署', '回滚'], description: '选择部署类型');&#125; 更多输入类型参考 https://jenkins.io/doc/book/pipeline/syntax/#parameters 12345678910111213parameters &#123; string(name: 'PERSON', defaultValue: 'Mr Jenkins', description: 'Who should I say hello to?') text(name: 'BIOGRAPHY', defaultValue: '', description: 'Enter some information about the person') booleanParam(name: 'TOGGLE', defaultValue: true, description: 'Toggle this value') choice(name: 'CHOICE', choices: ['One', 'Two', 'Three'], description: 'Pick something') password(name: 'PASSWORD', defaultValue: 'SECRET', description: 'Enter a password') file(name: "FILE", description: "Choose a file to upload")&#125; 5. triggers当然，也可以在 jenkinsfile 上定义任务的触发器，内部提供了 cron, pollSCM 和 upstream 三种类型的触发器。 123triggers &#123; cron('H */4 * * 1-5')&#125; 除了内置触发器外，许多插件也提供了触发器，比如 Generic Webhook Trigger 123456789101112131415161718triggers &#123; GenericTrigger( genericVariables: [ // 从参数中取值 [key: 'ref', value: '$.ref'] ], causeString: 'Triggered on $ref', token: 'test_imservice_ci', // 只有 url 中的 token=test_imservice_ci 才会触发 printContributedVariables: true, printPostContent: true, regexpFilterText: '$ref', regexpFilterExpression: 'refs/heads/' + BRANCH_NAME // 当 ref 为当前分支时才构建 // 注： 只在多分支流水线项目中才包含 BRANCH_NAME 字段 )&#125; 6. stagesstages 中的 stage 会显示在 jenkins 任务主页中的 Stage View 中。每个 stage 可以有很多个 steps，我们可以执行构建命令。 12345stage('打印环境变量') &#123; steps &#123; sh "printenv" &#125;&#125; 如果你不知道支持哪些流水线脚本，可以在任务主页中点击【Pipeline Syntax】进入页面，选择示例步骤，生成流水线脚本。 当然，可以在 steps 中使用 script 支持 groovy 脚本。比如以下脚本，在不同构建环境下设置不同的环境变量。 123456789101112stage('设置network') &#123; steps &#123; script &#123; if (env.DEPLOY_ENV == 'test') &#123; env.NETWORK='host' &#125; else &#123; env.NETWORK='' &#125; &#125; sh 'printenv' &#125;&#125; 7. post构建完成功或失败后，会触发后置处理 123456789post &#123; success &#123; sh 'printenv' &#125; failure &#123; echo 'build error' &#125;&#125; 8. 字符串groovy 有多种字符串定义的方式，只有双引号字符串可以插入参数。 12345678910111213'hello, world'"hello, $&#123;PARAMS&#125;"''' hello, world!'''""" hello, $&#123;PARAMS&#125;""" 9. 钉钉群通知 声明钉钉机器人 url 123environment &#123; DINGDING_ROBOT_URL = 'https://oapi.dingtalk.com/robot/send?access_token=123456'&#125; 将通知信息拼接成钉钉支持的格式，使用 curl 发送，参考 https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq 12345678910111213141516171819post &#123; success &#123; script &#123; def markdown = """ #### "$&#123;env.JOB_NAME&#125; 部署成功 [$&#123;env.BUILD_NUMBER&#125;]" """ def json = """ &#123; "msgtype": "markdown", "markdown": &#123; "title": "杭州天气", "text": "$&#123;markdown&#125;" &#125;, &#125; """ sh "curl -H 'Content-Type:application/json' -X POST --data '$&#123;json&#125;' $&#123;DINGDING_ROBOT_URL&#125;" &#125; &#125;&#125; 最好能够将上面的 json 拼接抽象成函数。 1234567891011121314151617181920212223pipeline &#123; // ... post &#123; success &#123; script &#123; def json = buildJSON('构建成功', '#### 构建成功...') sh "curl -H 'Content-Type:application/json' -X POST --data '$&#123;json&#125;' $&#123;DINGDING_ROBOT_URL&#125;" &#125; &#125; &#125;&#125;def buildJSON(title, markdown) &#123; return """ &#123; "msgtype": "markdown", "markdown":&#123; "title": "$&#123;title&#125;", "text":"$&#123;markdown&#125;" &#125; &#125; """&#125; 10. 常见问题 构建异常 failed to unshare namespaces: Cannot allocate memory 123[91mnsenter: failed to unshare namespaces: Cannot allocate memory[0m[91mcontainer_linux.go:262: starting container process caused &quot;process_linux.go:247: running exec setns process for init caused \&quot;exit status 34\&quot;&quot;[0moci runtime error: container_linux.go:262: starting container process caused &quot;process_linux.go:247: running exec setns process for init caused \&quot;exit status 34\&quot;&quot; 解决方案：连接 jenkins 服务器，执行 echo 1 &gt; /proc/sys/vm/drop_caches 释放内存 待更新。。 学习链接： https://jenkins.io/zh/doc/book/pipeline/]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jenkins</tag>
        <tag>linus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg-animate动画]]></title>
    <url>%2F2019%2F05%2F26%2Fsvg-animate%2F</url>
    <content type="text"><![CDATA[1. 属性 attributeName： 定义发生变化的属性名 attributeType： 当 attributeType=”XML” 时，attributeName 被认为是 XML 的属性；当 attributeType=”CSS” 时，attributeName 被认为是 css 的属性；不指定 attributeType 时，默认为 “auto”, 会将 attributeName 作为 css 的属性，如果无效，再将 attributeName 作为 XML 的属性 from、to、by：from 和 to 分别定义发生变化的属性的初始值和终止值。from 可缺省，表示初始值即为 animate 父元素相应的属性值。可用 by 替换 to，表示变化偏移量，可以理解为 to = from + by begin dur end：begin 定义动画开始时间，dur 定义动画所需时间，end 定义动画终止时间。时间单位 h：小时；min：分钟；s：秒；ms：毫秒。默认时间单位为 s。 fill：当 fill=”freeze” 时，动画终止时，发生变化的元素属性值停留在动画终止时的状态；当 fill=”remove” 时，动画终止时，发生变化的元素属性值回复到动画终起始时的状态。默认属性值为 remove。 repeatCount： indefinite 无限循环 2. animateTransform 实现 transform 属性改变的动画，animateTransform 来代替 animate 元素 type 属性指定需要改变的属性，如 translate scale rotate skewX skewY 等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;svg viewBox='0 0 200 200' width='600'&gt; &lt;rect x='10' y='10' width='20' height='20' fill='red' &gt; &lt;animate attributeName='width' from='20' to='300' dur='3s' fill='freeze' /&gt; &lt;animate attributeName='height' from='20' to='200' dur='3s' fill='freeze' /&gt; &lt;animate attributeName='fill' attributeType='XML' values='red; yellow; orange' dur='3s' fill='freeze' /&gt; &lt;animateTransform attributeName='transform' type='scale' attributeType='XML' from='1' to='0.2' dur='3s' fill='freeze' /&gt; &lt;/rect&gt;&lt;/svg&gt;&lt;div&gt; &lt;div onclick="this.click()"&gt;click&lt;/div&gt; &lt;svg viewBox='-50 -50 100 100' width='100' click="this.clickSvg()"&gt; &lt;circle cx='10' cy='0' r='6' fill='red' &gt; &lt;animate attributeName='opacity' values='0.8;0.8;0.6;0.4;0.6;0.8;0.8' dur='1.2s' repeatCount='indefinite' /&gt; &lt;/circle&gt; &lt;circle cx='-10' cy='0' r='6' fill='red' &gt; &lt;animate attributeName='opacity' values='0.8;0.8;0.8;0.4;0.8;0.8;0.8' dur='1.2s' begin='0.5' repeatCount='indefinite' /&gt; &lt;/circle&gt; &lt;circle cx='0' cy='10' r='6' fill='red' &gt; &lt;animate attributeName='opacity' values='0.8;0.8;0.6;0.4;0.6;0.8;0.8' dur='1.2s' begin='0.25' repeatCount='indefinite' /&gt; &lt;/circle&gt; &lt;circle cx='0' cy='-10' r='6' fill='red' &gt; &lt;animate attributeName='opacity' values='0.8;0.8;0.6;0.4;0.6;0.8;0.8' dur='1.2s' begin='0.75' repeatCount='indefinite' /&gt; &lt;/circle&gt;&lt;/svg&gt;&lt;/div&gt; 3. animateMotion animateMotion 可以让父元素沿着指定的路径运动 路径使用和 &lt;path&gt; 相同的方式进行定义 rotate 可以设置是否根据路径的正切角度来旋转 1234567891011121314151617&lt;svg viewBox='0 0 400 400' width='600' &gt; &lt;circle cx="0" cy="50" r="15" fill="red" &gt; &lt;animateMotion path="M 0 0 H 300 Z" dur="3s" repeatCount="indefinite" /&gt; &lt;/circle&gt;&lt;/svg&gt;&lt;svg viewBox='-150 -150 800 800' width='600' &gt; &lt;circle cx="0" cy="50" r="15" fill="red" &gt; &lt;animateMotion path="M 0 0 H 300 Z" dur="3s" repeatCount="indefinite" /&gt; &lt;/circle&gt; &lt;rect x='0' y='80' height='20' width='20' rx='3' fill="red" &gt; &lt;animateMotion path="M40 40, L160 80, L20 100, Z" dur="3s" repeatCount="indefinite" /&gt; &lt;/rect&gt; &lt;rect x='0' y='140' height='20' width='20' rx='3' fill="red" &gt; &lt;animateMotion path="M50 50, A50 50 0 0 0 150 150, A50 50 0 1 0 50 50" dur="3s" repeatCount="indefinite" rotate="auto" /&gt; &lt;/rect&gt;&lt;/svg&gt;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg-引用、裁剪、蒙版]]></title>
    <url>%2F2019%2F05%2F12%2Fsvg-%E5%BC%95%E7%94%A8%E8%A3%81%E5%89%AA%E8%92%99%E7%89%88%2F</url>
    <content type="text"><![CDATA[&lt;use&gt;：创建图形引用 &lt;clipPath&gt;：裁剪图形 &lt;mask&gt;：创建蒙版 1. &lt;use&gt; &lt;use&gt; 标签可以绘制重复的图形元素 使用 xlink:href 属性引用图形，xlink:href = “#id” 原型已经设置的属性，引用会继承，并且不能覆盖 2. &lt;clipPath&gt; 该标签用于定义剪切路径，标签内可创建任意数量的基本形状 图形使用 clip-path 属性来引用 clipPath 来做裁切，clip-path=”url(#clip-id)”、 clip-rule 用于确定哪些点是属于裁剪路径内部的点 所有在裁剪路径中的图形都可见，所有在裁剪路径外的图形都不可见 3. &lt;mask&gt; 蒙版（mask）是一种容器，它定义了一组图形，并将他们作为半透明的媒介，可以用来组合前景对象和背景 蒙版可以指定不同位置的透明度（裁剪路径要么是全透明，要么不可见） 蒙版的效果，基本就是根据蒙版中每个点的颜色和透明度计算出一个最终的透明度，然后在渲染对象的时候，在对象上面罩上这个带有不同透明度的蒙版层，体现出蒙版的遮挡效果]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg-文本]]></title>
    <url>%2F2019%2F05%2F05%2Fsvg-%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[svg 可以使用 &lt;text&gt;、&lt;tspan&gt; 来创建文本。 1. 位置 x、y 决定了文本在视图中显示的位置 dx、dy 用于设置文本相对于当前位置的偏移量 如果 dx、dy 的值是多个值，则从第二个值开始，表示文本内字符的间距 2. 对齐 text-anchor： 设置水平对齐，包括：start middle end inherit dominant-baseline： 设置垂直对齐，包括：auto central middle text-before-edge text-after-edge… 3. 样式 可以使用：fill stroke stroke-width opacity 等 svg 属性 可以使用：font-family、font-style、font-weight、font-variant、font-stretch、font-size、font-size-adjust、kerning、letter-spacing、word-spacing、text-decoration 等属性 4. tspan tspan 必须是一个 text 元素或其他 tspan 元素的子元素 x 为容器设置一个新绝对 x 坐标，它覆盖了默认的当前的文本位置。这个属性可以包含一个数列，他们将一个一个的应用到 tspan 元素内的每一个字符上（y 同理） dx 从当前位置，用一个水平偏移开始绘制文本。这里，可以提供一个值数列，可以应用到连续的字体，因此每次累计一个偏移（dy 同理） rotate 把所有字符旋转一个角度。如果是一个数列，则使每个字符分别旋转到那个值，剩下的字符根据最后一个值旋转 5. textPath 元素利用路径文本 textPath 的 xlink:href 属性取得一个任意路径，把字符对齐到路径 使用 textPath 时， x 位置路径，y 无效 startOffset 确定排列的起始位置 6. 示例1234567891011121314151617181920212223242526272829303132333435&lt;svg viewBox='0 0 800 200' width='800' height='200' style='border: 1px solid'&gt; &lt;polyline points="60 20, 60 80" fill="transparent" stroke="black"/&gt; &lt;text x="60" y="20" text-anchor="start"&gt;start&lt;/text&gt; &lt;text x="60" y="20" text-anchor="start"&gt;start&lt;/text&gt; &lt;text x="60" y="50" text-anchor="middle"&gt;middle&lt;/text&gt; &lt;text x="60" y="80" text-anchor="end"&gt;end&lt;/text&gt; &lt;polyline points="10 150, 790 150" fill="transparent" stroke="black"/&gt; &lt;text x="0" y="150" dominant-baseline="start"&gt;start&lt;/text&gt; &lt;text x="0" y="150" dominant-baseline="start"&gt;start&lt;/text&gt; &lt;text x="50" y="150" dominant-baseline="central"&gt;central&lt;/text&gt; &lt;text x="120" y="150" dominant-baseline="middle"&gt;middle&lt;/text&gt; &lt;text x="180" y="150" dominant-baseline="text-before-edge"&gt;text-before-edge&lt;/text&gt; &lt;text x="250" y="150" dominant-baseline="text-after-edge"&gt;text-after-edge&lt;/text&gt; &lt;text x="380" y="150" dominant-baseline="no-change"&gt;no-change&lt;/text&gt; &lt;text x="470" y="150" dominant-baseline="hanging"&gt;hanging&lt;/text&gt; &lt;text x="530" y="150" dominant-baseline="reset-size"&gt;reset-size&lt;/text&gt; &lt;text x="620" y="150" dominant-baseline="ideographic"&gt;ideographic&lt;/text&gt;&lt;/svg&gt;&lt;svg viewBox='0 0 400 200' width='400' height='200' style='border: 1px solid'&gt; &lt;text x='20' y='50' stroke='red' font-size='60px' font-weight='bold' fill='none' letter-spacing='3' stroke-width='0.5'&gt;leo&lt;/text&gt; &lt;text x='20' y='100' font-size='18'&gt; &lt;tspan font-weight="bold" font-size='30'&gt;leo&lt;/tspan&gt;weiy &lt;/text&gt; &lt;text x="20" y="150"&gt; leo&lt;tspan x="100 100" y="150 130 110" dx="0 10 10 10 10 10" dy='0 10 10' rotate="15 15 60" font-size='20' font-weight="bold" &gt;weiy&lt;/tspan&gt; &lt;/text&gt;&lt;/svg&gt;&lt;svg viewBox='0 0 400 200' width='400' height='200' style='border: 1px solid'&gt; &lt;path id="my_path" d="M20 40, Q100 100 200 40" fill="none" stroke='red' /&gt; &lt;text x='10'&gt; &lt;textPath startOffset='10%' xlink:href="#my_path"&gt;casstime bricks&lt;/textPath&gt; &lt;/text&gt;&lt;/svg&gt; 学习链接 https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Texts]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg-path]]></title>
    <url>%2F2019%2F04%2F28%2Fsvg-path%2F</url>
    <content type="text"><![CDATA[1. 介绍path 字符串由一系列命令序列组成，序列的首字母表示命令类型，后面跟的是命令的坐标值或命令的设定。 123&lt;path d='M0, 0 L10, 20 C30-10, 40,20,100,100' stroke='red' /&gt;&lt;path d='M0 0 L10 20 C30 -10 40 20 100 100' stroke='red' /&gt;&lt;path d='M0 0, L10 20, C30 10, 40 20 100 100' stroke='red' /&gt; 属性 d 实际上是一个字符串，包含了一系列路径描述。 2. 命令 命令 描述 M/m(x,y)+ 移动当前位置 L/l(x,y)+ 从当前位置绘制线段到指定位置 H/h(x)+ 从当前位置绘制水平线到达指定的 x 坐标 V/v(y)+ 从当前位置绘制竖直线到指定的 y 坐标 Z/z 闭合当前路径 C/c(x1,y1,x2,y2,x,y)+ 从当前位置绘制三次贝塞尔曲线到指定位置 S/s(x2,y2,x,y)+ 从当前位置光滑绘制三次贝塞尔曲线到指定位置 Q/q(x1,y1,x,y)+ 从当前位置绘制二次贝塞尔曲线到指定位置 T/t(x,y)+ 从当前位置光滑绘制二次贝塞尔曲线到指定位置 A/a(rx,ry,xr,laf,sf,x,y) 从当前位置绘制弧线到指定位置 区分大小写，大写表示坐标参数为绝对位置，小写则为相对位置 最后的参数表示最终要到达的位置 上一个命令结束的位置就是下一个命令开始的位置 命令可以重复参数，表示重复执行同一条命令 3. 直线命令1234567&lt;svg viewBox='0 0 400 400' width='400' height='400' style='border: 1pxsolid green'&gt; &lt;path d='M10 10, L80 80' stroke='red' /&gt; &lt;path d='M10 100, H200' stroke='red' /&gt; &lt;path d='M80 120, V180' stroke='red' /&gt; &lt;path d='M80 200, L200 260, L40 220, Z' stroke='red' fill='none'/&gt;&lt;/svg&gt; 4. 弧线命令A(rx, ry, xr, laf, sf, x, y) - 绘制弧线 rx - (radius-x) 弧线所在椭圆的 x 半轴长 ry - (radius-y) 弧线所在椭圆的 y 半轴长 xr - (xAxis-rotation) 弧线所在椭圆的长轴角度 laf - (large-arc-flag) 是否选择弧长较长的那段弧 sf - (sweep-flag) 是否选择逆时针方向的那段弧 x, y - 弧的终点位置 1234567&lt;svg viewBox='0 0 200 200' width='200' height='200' style='border: 1px solid green'&gt; &lt;path d='M50 50, A50 50 0 0 0 150 150, A50 50 0 1 0 50 50' stroke='red' fill='none' stroke-width="2" /&gt;&lt;/svg&gt;&lt;svg viewBox='0 0 200 200' width='200' height='200' style='border: 1px solid green'&gt; &lt;path d='M50 50, A40 30 0 0 0 150 150, A40 30 0 1 0 50 50' stroke='red' fill='none' stroke-width="2" /&gt;&lt;/svg&gt; 5. 贝塞尔曲线介绍 12345678910111213141516171819&lt;svg viewBox='-10 0 220 200' width='200' height='200' style='border: 1px solid green'&gt; &lt;path d='M0 100, Q100 0 200 100 ' stroke='red' fill='none' /&gt;&lt;/svg&gt;&lt;svg viewBox='-10 0 220 200' width='200' height='200' style='border: 1px solid green'&gt; &lt;path d='M0 100, Q20 0 200 100 ' stroke='red' fill='none' /&gt;&lt;/svg&gt;&lt;svg viewBox='-10 0 220 200' width='200' height='200' style='border: 1px solid green'&gt; &lt;path d='M0 100, Q180 0 200 100 ' stroke='red' fill='none' /&gt;&lt;/svg&gt;&lt;svg viewBox='-10 0 220 200' width='200' height='200' style='border: 1px solid green'&gt; &lt;path d='M0 100, C20 0 100 200 200 100 ' stroke='red' fill='none' /&gt;&lt;/svg&gt;&lt;svg viewBox='-10 0 220 200' width='200' height='200' style='border: 1px solid green'&gt; &lt;path d='M0 100, T20 30 100 100 200 100 ' stroke='red' fill='none' /&gt;&lt;/svg&gt; 学习链接： https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg-元素与属性]]></title>
    <url>%2F2019%2F04%2F26%2Fsvg-%E5%85%83%E7%B4%A0%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1. 标签 &lt;svg&gt;：包裹并定义整个矢量图； &lt;line&gt;：创建一条直线； &lt;polyline&gt;：创建折线； &lt;polygon&gt;：创建多边形； &lt;rect&gt;：创建矩形； &lt;circle&gt;：创建圆形； &lt;ellipse&gt;：创建圆形和椭圆； &lt;g&gt;：将多种形状组合起来。将组合后的形状置于 &lt;defs&gt; 中可以让它能够被复用； &lt;text&gt;、&lt;tspan&gt;：创建文本元素； &lt;path&gt;：通过指定点以及点与点之间的线来创建任意形状； &lt;defs&gt;：在 defs 元素中定义的图形元素不会直接呈现，建议将引用的元素定义在 &lt;defs&gt; 里； &lt;use&gt;：获取在 &lt;defs&gt; 中定义的复用对象并在 svg 中显示出来； &lt;clipPath&gt;：指定可绘制区域，当绘制的图形超出了剪切路径所指定的区域，超出区域的部分将不会被绘制； &lt;mask&gt;：用于定义遮罩元素，可以带有透明度； 2. 属性 fill：颜色填充； 例如： fill=”#ff0” stroke：描边的颜色； 例如：stroke=”#ff0” stroke-width：描边宽度； 例如：stroke-width=2 opacity：透明度； 例如：opacity=”0.2” transform： 变形； 例如：transform=”rotate(30deg)” 3. 基础图形实例和分析12345678910&lt;svg viewBox='0 0 800 400' width='800' height='400' style='border: 1pxsolid green'&gt; &lt;line x1='0' y1='0' x2='100' y2='100' stroke='red' /&gt; &lt;polyline points='100 150 150 150 150 100' stroke='red' fill='none'/&gt; &lt;polygon points='200 250 250 250 250 100' stroke='red' fill='none' /&gt; &lt;rect x='300' y='80' width='100' height='50' fill='red' rx='10'ry='20' /&gt; &lt;circle cx='400' cy='200' r='50' fill='red' opacity='0.3' /&gt; &lt;ellipse cx='550' cy='200' rx='80' ry='30' fill='red' opacity='0.8' /&gt;&lt;/svg&gt; 学习链接： https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg-概述]]></title>
    <url>%2F2019%2F04%2F18%2Fsvg-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1. 介绍 可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述基于二维的矢量图形的，基于 XML 的标记语言。本质上，SVG 相对于图像，就好比 HTML 相对于文本; 文件后缀是 .svg； namespace 是 http://www.w3.org/2000/svg； 2. 优点 可被非常多的工具读取和修改； 相对 jpg, png 尺寸更小，切可压缩性更强； 可伸缩； 可在图像质量不降低的情况下被放大； 文本是可以搜索的； 3. 兼容性 4. 坐标系统对于所有元素，SVG使用的坐标系统或者说网格系统，和Canvas用的差不多（所有计算机绘图都差不多）。这种坐标系统是： 以页面的左上角为(0,0)坐标点，坐标以像素为单位，x 轴正方向是向右，y 轴正方向是向下。注意，这和你小时候所教的绘图方式是相反的。但是在HTML文档中，元素都是用这种方式定位的。 1&lt;rect x="0" y="0" width="100" height="100" /&gt; SVG中的四个坐标系包括用户坐标系、自身坐标系、前驱坐标系和参考坐标系。其中，用户坐标系和自身坐标系是客观的坐标系，而前驱坐标系和参考坐标系是相对的坐标系 用户坐标系：即世界坐标系，svg 坐标系本身； 自身坐标系：图形或图形分组的坐标系； 前驱坐标系：父容器的坐标系；svg 的前驱坐标系是世界坐标系； 参考坐标系：参考其他坐标系来判断自身的情况时使用； 5. 基础概念 视窗：在 svg 标签上设置 width、 height 来控制视窗(viewport)； 世界： svg 代码定义的世界； 视野：世界是无穷大的，视野是观察世界的一个矩形区域；在 svg 中，提供了 viewBox 和 preserveAspectRatio 属性来控制视野； 6. 使用 img、iframe、object等标签插入网页； css 使用； 直接插入网页； 网页直接打开； 12345678910111213141516171819&lt;img src="demo.svg" /&gt;&lt;iframe src="demo.svg" /&gt;&lt;object src="demo.svg" type="image/svg+xml" /&gt;.demo &#123; background: url(demo.svg);&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 60" preserveAspectRatio="xMidYMid meet" &gt; &lt;circle cx="40" cy="30" r="5" /&gt; &lt;svg&gt; &lt;/body&gt;&lt;/html&gt; 7. 实际应用 iconfont highCharts D3.js 学习链接： https://developer.mozilla.org/zh-CN/docs/Web/SVG https://www.cnblogs.com/xiaohuochai/p/7482765.html]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[taro 小程序生命周期]]></title>
    <url>%2F2019%2F03%2F20%2Ftaro%2F</url>
    <content type="text"><![CDATA[1. 微信小程序的生命周期 页面生命周期，如上图所示： onLoad： 监听页面加载 onShow： 监听页面显示 onReady： 监听页面初次渲染完成 onHide： 监听页面隐藏 onUnload：监听页面卸载 除此之外，还有页面相关事件处理函数（点击查看详情)）： onPullDownRefresh：监听用户下拉动作 onReachBottom： 页面上拉触底事件的处理函数 onShareAppMessage：用户点击右上角转发 onPageScroll： 页面滚动触发事件的处理函数 onResize： 页面尺寸改变时触发，详见 响应显示区域变化 onTabItemTap： 当前是 tab 页时，点击 tab 时触发 2. taro 的生命周期taro 是基于 react 的，所以先回顾下 react 的生命周期: 接下来，我们对应下 taro 和 微信小程序的生命周期（点击查看详情） 2.1 入口生命周期 生命周期方法 作用 说明 componentWillMount 程序被载入 在微信小程序里对应的生命周期是 onLaunch componentDidMount 程序被载入 在微信小程序里对应的生命周期是 onLaunch componentDidShow 程序展示出来 在微信小程序里对应的生命周期是 onShow，在 H5/RN 中同步实现 componentDidHide 程序被隐藏 在微信小程序里对应的生命周期是 onHide，在 H5/RN 中同步实现 componentDidCatchError 程序发生脚本错误或 API 调用报错 在微信小程序里对应的生命周期是 onError，H5/RN 中尚未实现 componentDidNotFound 程序要打开的页面不存在 在微信小程序里对应的生命周期是onPageNotFound，其他端尚未实现 2.2 页面生命周期由于页面 JS 也继承自 Component 组件基类，所以页面同样拥有生命周期，页面的生命周期方法如下： 生命周期方法 作用 说明 componentWillMount 页面加载时触发，一个页面只会调用一次，此时页面 DOM 尚未准备好，还不能和视图层进行交互 在微信小程序里对应的生命周期是 onLoad componentDidMount 页面初次渲染完成时触发，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互 在微信小程序里对应的生命周期是 onReady shouldComponentUpdate 页面是否需要更新，返回 false 不继续更新，否则继续走更新流程 componentWillUpdate 页面即将更新 componentDidUpdate 页面更新完毕 componentWillUnmount 页面卸载时触发，如 redirectTo 或 navigateBack 到其他页面时 在微信小程序里对应的生命周期是 onUnload componentDidShow 页面显示/切入前台时触发 在微信小程序里对应的生命周期是 onShow， H5同步实现 componentDidHide 页面隐藏/切入后台时触发， 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等 在微信小程序里对应的生命周期是 onHide， H5同步实现 2.3 组件的生命周期由于组件 JS 也继承自 Component 组件基类，所以组件同样拥有生命周期，组件的生命周期方法如下（具体可以去官网查看）： componentWillMount componentDidMount componentWillReceiveProps 已经装载的组件接收到新属性前调用 shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount 学习链接： https://developers.weixin.qq.com/miniprogram/dev/guide/framework/page-life-cycle.html https://nervjs.github.io/taro/docs/apis/about/tarocomponent.html#%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>taro</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Puppeteer 实现钉钉每日推荐]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%88%A9%E7%94%A8Puppeteer%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%AF%8F%E6%97%A5%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[Puppeteer 介绍利用这个工具，我们能做一个操纵页面的人。 Puppeteer 是一个 Nodejs 的库，支持调用 Chrome 的 API 来操纵 Web，相比较 Selenium 或是 PhantomJs,它最大的特点就是它的操作 Dom 可以完全在内存中进行模拟既在 V8 引擎中处理而不打开浏览器，而且关键是这个是 Chrome 团队在维护，会拥有更好的兼容性和前景。 Puppeteer 用处 利用网页生成PDF、图片 爬取SPA应用，并生成预渲染内容（即“SSR” 服务端渲染） 可以从网站抓取内容 自动化表单提交、UI测试、键盘输入等 帮你创建一个最新的自动化测试环境（chrome），可以直接在此运行测试用例6.捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题 Puppeteer 使用1. 安装 Puppeteer123456789101112131415# 安装命令npm i puppeteer --save# 错误信息ERROR: Failed to download Chromium r515411! Set "PUPPETEER_SKIP_CHROMIUM_DOWNLOAD" env variable to skip download.# 设置环境变量跳过下载 Chromiumset PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1# 或者可以这样干，只下载模块而不buildnpm i --save puppeteer --ignore-scripts# 成功安装模块+ puppeteer@0.13.0added 1 package in 1.77s 若安装不成功，可手动下载，下载完后将压缩包解压，会有个 Chromium.app，将其放在你喜欢的目录下 2. 使用 API puppeteer.launch 启动浏览器实例 browser.newPage() 创建一个新页面 page.goto 进入指定网页 page.screenshot 截图 page.type 获取输入框焦点并输入文字 page.keyboard.press 模拟键盘按下某个按键，目前mac上组合键无效为已知bug page.waitFor 页面等待，可以是时间、某个元素、某个函数 page.frames() 获取当前页面所有的 iframe，然后根据 iframe 的名字精确获取某个想要的 iframe iframe.$(‘.srchsongst’) 获取 iframe 中的某个元素 iframe.evaluate() 在浏览器中执行函数，相当于在控制台中执行函数，返回一个 Promise page.click() 点击一个元素 iframe.$eval() 相当于在 iframe 中运行 document.queryselector 获取指定元素，并将其作为第一个参数传递 iframe.$$eval 相当于在 iframe 中运行 document.querySelectorAll 获取指定元素数组，并将其作为第一个参数传递 Puppeteer API 钉钉接口接口 API 示例代码https://github.com/weiyuan0609/dding-daily 参考： puppeteer 官方文档]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
        <tag>Puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认知复杂度-衡量代码可理解性的新方法]]></title>
    <url>%2F2018%2F11%2F06%2F%E8%AE%A4%E7%9F%A5%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thomas J. McCabe 在 1976 年提出了圆环复杂度（Cyclomatic Complexity），作为指导程序员编写“既可测试又可维护”的方法。在SonarSource，我们认为圆环复杂度在测量可测性方面效果很好，但不适合测试可维护性。 这就是我们提出认知复杂（Cognitive Complexity）的原因，您将在即将到来的新版语言分析器中看到这一点。 我们用认知复杂度来更好地衡量代码的难以理解的程度。 圆环复杂度 不能衡量可维护性让我们通过下面的例子来进行阐述: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两种方法具有相同的圆环复杂度，但显然不具有相同的可维护性。 当然，这种比较可能不完全公平; 甚至 McCabe 在他的原始论文中也承认，在 switch 语句中 case 标签的复杂度计算似乎并不正确。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一方面，这正是圆环复杂度的问题。 这些分数肯定会告诉你需要多少测试用例才能覆盖给定的方法，但从可维护性的角度来看，它们并不总是正确的。 此外，即使最简单的方法得到的圆环复杂度也为1，一个大型的类可能与充满强烈逻辑的小类具有相同的圆环复杂度。 研究表明，在应用层面圆环复杂度与代码行相关，所以它实际上并没有告诉你任何新东西。 用认知复杂度解决问题吧&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是为什么我们制定了认知复杂度，它试图将一个方法的控制流程有多难以理解进行衡量并降低此复杂性。我会在一分钟内详细介绍一些细节，但首先我想谈一下我们为什么要制定认知复杂度。显然，我们的主要目标是将计算的可维护性进行直观“公平”地表示。 但是，我们非常清楚的知道，当我们衡量了之后，我们就会尝试去改进它。正因为如此，我们希望认知复杂度能够通过改善代码结构来获得良好的干净的编码实践，这些代码结构需要额外的努力去理解，我们应该忽略那些使代码更易于阅读的结构。 我们把这个指导思想归结为三条简单的规则： 当线性的（从上到下，从左到右）代码结构中存在中断时将认知复杂度加1 当内嵌了打断工作流的代码结构时将认知复杂度加1 忽略那些将多行代码压缩为一行代码的结构 示例： 将以上三个规则记在心里，让我们一起分析下面两个方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所提到的，用圆环复杂度衡量代码可读性的其中一个最不合理地方在于它对 switch 语句的处理。而在认知复杂度中，对于一整个 switch 结构（包括了所有的 case 语句），其度量值只增加一次。为什么只增加一次呢？简短来说，因为认知复杂度是用来衡量代码难以理解的程度，而 switch 语句很容易被理解。另一方面，对于其他的流程控制语句，认知复杂度规则以类似的方式对待，如循环语句 for、while、do while；三元操作符 if/#if/#ifdef…else,if/elsif/elif/…,还有 catch 语句。另外当遇到 goto、break、continue 标签，内嵌的控制流时复杂度也会增加。 正如你所看到的，认知复杂度考虑了使方法更难理解的东西 —— 嵌套语句和 continue 语句。因此，尽管以上示例中的两种方法具有相同的环复杂度分数，但他们的认知复杂度分数清楚地反映了他们在可理解性方面的巨大差异。 在查看这些示例时，您可能已经注意到，认知复杂度不会因为方法本身增加。这意味着简单的类的认知复杂度为零： 所以现在的类级别的复杂度指标变得有意义。您可以查看类列表和他们的认知复杂度分数，并且知道当您看到一个很高的数字时，这意味着 class 中有很多逻辑，而不仅仅是有很多方法。 开始使用 Cognitive 复杂度吧此时，你已经对认知复杂度有一定高度了解。布尔运算符的认知复杂度计算方式存在一些差异，但是你可以阅读白皮书来获得这些细节。希望你渴望开始使用认知复杂度，并想知道何时可以使用能够测量认知复杂度的工具。 我们将开始在各种语言中添加方法级别的认知复杂度规则，类似于现有的圆环复杂度规则。您将在主要的几种语言中看到：Java，JavaScript，C＃和C / C ++ / Objective-C。同时，我们将纠正现有的方法级别的“圆环复杂性”规则的实现，以真正衡量圆形复杂度（现在，它们是圆形和基本复杂度的组合）。 最终，我们可能会添加类/文件级别的认知复杂度规则和指标。但我们先从添加方法级别的复杂度规则开始吧！ 最后推荐一个 vscode 插件用于计算 js 代码复杂性，提升重构乐趣CodeMetrics 参考： https://www.testwo.com/article/1210]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[undefined null 区别]]></title>
    <url>%2F2018%2F10%2F10%2Fundefined-null%2F</url>
    <content type="text"><![CDATA[大多数计算机语言，有且仅有一个表示”无”的值，比如，C 语言的 NULL ，Java 语言的 null ，Python 语言的 None，Ruby 语言的 nil 。 但是，JavaScript 语言居然有两个表示”无”的值：undefined 和 null 。 Undefined 和 Null 是 Javascript 中两种特殊的原始数据类型(Primary Type)，它们都只有一个值，分别对应 undefined 和 null ，这两种不同类型的值，既有着不同的语义和场景，又表现出较为相似的行为 1. 不同 null null 的字面意思是：空值 。这个值的语义是，希望表示, 一个对象被人为的重置为空对象，而非一个变量最原始的状态。在内存里的表示就是，栈中的变量没有指向堆中的内存对象，即： 当一个对象被赋值了null 以后，原来的对象在内存中就处于游离状态，GC 会择机回收该对象并释放内存。因此，如果需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。 与 null 相关的另外一个问题需要解释一下： 1typeof null == 'object' null 有属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。 12345- 000 - 对象，数据是对象的应用- 1 - 整型，数据是31位带符号整数- 010 - 双精度类型，数据是双精度数字- 100 - 字符串，数据是字符串- 110 - 布尔类型，数据是布尔值 其实，我们可以通过另一种方法获取 null 的真实类型 1Object.prototype.toString.call(null) ; // [object Null] 通过 Object 原型上的toString() 方法可以获取到 JavaScript 中对象的真实数据类型，当然 undefined 类型也可以通过这种方式来获取： 1Object.prototype.toString.call(undefined) ; // [object Undefined] undefined undefined 的字面意思就是：未定义的值 。这个值的语义是，希望表示一个变量最原始的状态，而非人为操作的结果。这种原始状态会在以下 5 种场景中出现： 12345- 变量被声明了，但没有赋值时，就等于undefined。- 调用函数时，应该提供的参数没有提供，该参数等于undefined。- 对象没有赋值的属性，该属性的值为undefined。- 函数没有返回值时，默认返回undefined。- 使用 void 对表达式求值 123456789101112131415161718var i;i // undefinedfunction f(x)&#123;console.log(x)&#125;f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined// ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefinedvoid 0 ; // undefinedvoid false; // undefinedvoid []; // undefinedvoid null; // undefinedvoid function fn()&#123;&#125; ; // undefined 2. 相似性虽然 undefined 和 null 的语义和场景不同，但总而言之，它们都表示的是一个无效的值。 因此，在 JavaScript 中对这类值访问属性时，都会得到异常的结果： 12null.toString(); // Cannot read property 'toString' of nullundefined.toString(); // Cannot read property 'toString' of undefined ECMAScript 规范认为，既然 null 和 undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性，即有 1undefined == null; // true 不要试图通过转换数据类型来解释这个结论，因为： 12345Number(null); // 0Number(undefined); // NaN// 在比较相等性之前，null 没有被转换为其他类型null == 0 ; //false 但 === 会返回 false ，因为全等操作 === 在比较相等性的时候，不会主动转换分项的数据类型，而两者又不属于同一种类型： 12undefined === null; // false，类型不相同undefined !== null; // true, 类型不相同 总结: 用一句话总结两者的区别就是：undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。 参考链接： http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html https://www.cnblogs.com/onepixel/p/7337248.html]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grid布局]]></title>
    <url>%2F2018%2F09%2F03%2Fgrid%2F</url>
    <content type="text"><![CDATA[Web 的 Grid 模型: 点击此处 介绍：CSS 网格布局（又名“网格”）是一种基于网格的二维布局系统，旨在完全改变我们设计基于网格的用户界面的方式。CSS 一直被用来布局我们的网页，但它从未做过很好的工作。首先，我们使用表格，然后是浮点数，定位和内联块，但所有这些方法基本上都是黑客攻击，并省略了很多重要的功能（例如垂直居中）。Flexbox 有所帮助，但它适用于更简单的一维布局，而不是复杂的二维布局（ Flexbox 和 Grid 实际上可以很好地协同工作）。Grid 是第一个专门用于解决布局问题的CSS模块，只要我们一直在制作网站，我们就一直在讨论这些问题。 点击查看详情 阮一峰 Grid]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN 开发常见问题]]></title>
    <url>%2F2018%2F08%2F10%2Frn%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[RN 开发常见问题: 点击此处]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>React-Native</tag>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 工作台]]></title>
    <url>%2F2018%2F07%2F01%2Fmac%E5%B7%A5%E4%BD%9C%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[官方 mac 快捷键：https://support.apple.com/zh-cn/HT201236 记录下我平时开发时安装的一些工具： 1. AlfredAlfred 是一个非常非常强大的效率工具！快捷键呼出 search 框，输入你想找的任何东西得首字母或者前几位、缩写，然后上下方向键找到你的目标，回车咔擦一按！Done！而且还支持自定义 2. sourceTree好用的 git 仓库管理客户端 3. typora好用的 markdown 写作工具 4. vscode好用的 IDE 5. Postman接口调试 6. Dash开发文档集合应用。安装常用文档之后，遇到什么 API 或者 CSS 属性忘记了，直接在里面搜索即可。与传统的使用 google 搜索相比，用这个定位更加快速，文档也采用比较权威的官方文档，比较精准，此外也附带了 google 搜索结果。 7. 有道云笔记记录下平时的内容 8. xcode调试 ios 端 app 8. android studio调试 android 端 app 9. TeamViewer远程桌面连接 10. Charles抓包工具，类似 fiddler 11. BrowserSync使用它可以跨平台的同步测试，简单的说，你的操作也会同步到其他设备上，比如你在手机上滚动页面，它会在电脑上也同步滚动桌面版的页面等等 12. Parallels Destop 或 virtualbox桌面虚拟机 13. HOMEBREW软件包的管理器 14. Chromechrome 浏览器 15. 有道词典翻译使用，经常和 谷歌翻译一起使用 16. oh my zsh多姿多彩的终端 17. Bartender 2帮助我们整理屏幕顶部菜单栏图标的工具。 18 iStat Menus监控电脑cpu，ram，network，温度 19. XMind是一款实用的思维导图软件 20. licecap是一款屏幕录制工具，支持导出 GIF 动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围 21. DBeaverGithub开源，免费的数据库工具 22. 百度网盘资料备份 23. pap.er桌面壁纸 。。。。。。 24. 其他github 推荐 mac 工具]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 开发 React-Native 项目]]></title>
    <url>%2F2018%2F06%2F24%2FTypeScript%E5%BC%80%E5%8F%91ReactNative%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[最近，项目组准备用 TypeScript (以下简称 TS)开发 ReactNative (以下简称 RN)组件库 参考微软的 TS 项目 TypeScript-React-Native-Starter，实践了一把。 1. 初始化一个 RN 项目 可以参考下 RN 的官方文档。 123npm install -g yarn react-native-clireact-native init MyAwesomeProjectcd MyAwesomeProject 2. 添加 TS接下来就是引入 TS，步骤如下： 安装 TS 安装 React Native TypeScript Transformer 初始化一个空的 TS 配置文件，接下来将配置它 添加一个空的 React Native TypeScript Transformer 配置文件，接下来将配置它 添加 RN 和 React 的 typings 12345yarn add --dev typescriptyarn add --dev react-native-typescript-transformeryarn tsc --init --pretty --jsx reacttouch rn-cli.config.jsyarn add --dev @types/react @types/react-native 该 tsconfig.json 文件包含 TS 编译的所有设置。上面的命令创建的默认值大多很好。打开文件并取消注释以下行： 12345&#123; ... // "allowSyntheticDefaultImports": true, /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ ...&#125; rn-cli.config.js 文件包含 React Native TypeScript Transformer 的设置。打开它并添加以下内容： 12345678module.exports = &#123; getTransformModulePath() &#123; return require.resolve("react-native-typescript-transformer"); &#125;, getSourceExts() &#123; return ["ts", "tsx"]; &#125;&#125;; 3. 将代码迁移到 TS将生成的 App.js 和 tests/App.js 文件重命名为 App.tsx 。index.js 需要使用 .js 扩展名。所有新文件都应使用 .tsx 扩展名（或者 .ts，前提是该文件不包含任何 JSX）。 接下来，打开 App.tsx 并修改文件顶部的导入： 123-import React, &#123; Component &#125; from &apos;react&apos;;+import React from &apos;react&apos;+import &#123; Component &#125; from &apos;react&apos;; 现在应该能够运行 RN 应用程序。 4. 添加 TS 项目测试架构选用 Jest，添加 ts-jest 到 devDependencies。 1yarn add --dev ts-jest 然后，打开 package.json 并用 jest 以下内容替换该字段： 123456789101112131415161718"jest": &#123; "preset": "react-native", "moduleFileExtensions": [ "ts", "tsx", "js" ], "transform": &#123; "^.+\\.(js)$": "&lt;rootDir&gt;/node_modules/babel-jest", "\\.(ts|tsx)$": "&lt;rootDir&gt;/node_modules/ts-jest/preprocessor.js" &#125;, "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$", "testPathIgnorePatterns": [ "\\.snap$", "&lt;rootDir&gt;/node_modules/" ], "cacheDirectory": ".jest/cache"&#125; ts-jest 将配置 Jest 运行 .ts 和 .tsx 文件。 5. 安装类型声明依赖项需要 Jest，React 和 React Native 以及 React Test Renderer 的类型。将这些声明文件包保存到 dev 依赖项中，因为我们不会将此包作为库发布到 npm 。如果我们是，我们可能必须将其中一些添加为常规依赖项。 1yarn add --dev @types/jest @types/react @types/react-native @types/react-test-renderer 可以查看更多关于 .d.ts 文件. 6. 忽略更多文件在 .gitignore 文件添加以下内容: 123# Jest#.jest/ 7. 添加 RN 组件继续创建一个 Hello.tsx 组件。创建 components 目录并添加以下示例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// components/Hello.tsximport React from "react"import &#123; Button, StyleSheet, Text, View &#125; from "react-native"export interface Props &#123; name: string enthusiasmLevel?: number onIncrement?: () =&gt; void onDecrement?: () =&gt; void&#125;interface State &#123; enthusiasmLevel: number&#125;export class Hello extends React.Component&lt;Props, State&gt; &#123; constructor(props: Props) &#123; super(props) if ((props.enthusiasmLevel || 0) &lt;= 0) &#123; throw new Error("You could be a little more enthusiastic. :D") &#125; this.state = &#123; enthusiasmLevel: props.enthusiasmLevel || 1 &#125; &#125; onIncrement = () =&gt; this.setState(&#123; enthusiasmLevel: this.state.enthusiasmLevel + 1 &#125;); onDecrement = () =&gt; this.setState(&#123; enthusiasmLevel: this.state.enthusiasmLevel - 1 &#125;); getExclamationMarks = (numChars: number) =&gt; Array(numChars + 1).join("!") render() &#123; return ( &lt;View style=&#123;styles.root&#125;&gt; &lt;Text style=&#123;styles.greeting&#125;&gt; Hello &#123;this.props.name + this.getExclamationMarks(this.state.enthusiasmLevel)&#125; &lt;/Text&gt; &lt;View style=&#123;styles.buttons&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Button title="-" onPress=&#123;this.onDecrement&#125; accessibilityLabel="decrement" color="red" /&gt; &lt;/View&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Button title="+" onPress=&#123;this.onIncrement&#125; accessibilityLabel="increment" color="blue" /&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125;// stylesconst styles = StyleSheet.create(&#123; root: &#123; alignItems: "center", alignSelf: "center" &#125;, buttons: &#123; flexDirection: "row", minHeight: 70, alignItems: "stretch", alignSelf: "center", borderWidth: 5 &#125;, button: &#123; flex: 1, paddingVertical: 0 &#125;, greeting: &#123; color: "#999", fontWeight: "bold" &#125;&#125;) 8. 添加组件测试安装 react-addons-test-utils 1yarn add --dev react-addons-test-utils 现在在 tests 的 components 目录中创建一个文件夹并添加一个测试 Hello.tsx： 12345678910// components/__tests__/Hello.tsximport React from 'react'import renderer from 'react-test-renderer'import &#123; Hello &#125; from "../Hello"it("renders correctly with defaults", () =&gt; &#123; const button = renderer.create(&lt;Hello name="World" enthusiasmLevel=&#123;1&#125; /&gt;).toJSON() expect(button).toMatchSnapshot()&#125;) 第一次运行测试时，它将创建渲染组件的快照并将其存储在 components/tests/snapshots/Hello.tsx.snap 文件中。修改组件时，您需要更新快照并查看更新以进行无意的更改。 您可以在 此处阅读 有关测试 RN 组件的更多信息。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>TypeScript</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时序图]]></title>
    <url>%2F2018%2F06%2F17%2F%E6%97%B6%E5%BA%8F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[某某说过，字不如表，表不如图；好的图表可以帮助我们快速了解系统架构和业务逻辑。最近在给一个 IM 项目整理业务的时候，重新学习了下时序图的画法。 一、什么是时序图时序图（Sequence Diagram），亦称为序列图、循序图或顺序图，是一种 UML 交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。时序图是一个二维图，横轴表示对象，纵轴表示时间，消息在各对象之间横向传递，依照时间顺序纵向排列。 二、时序图的作用是什么 展示对象之间交互的顺序。将交互行为建模为消息传递，通过描述消息是如何在对象间发送和接收的来动态展示对象之间的交互； 相对于其他 UML 图，时序图更强调交互的时间顺序； 可以直观的描述并发进程。 三、组成元素有哪些1. 角色（Actor）系统角色，可以是人、机器、其他系统、子系统。 2. 对象（Object） 注意：对象的排列顺序并不重要，但是为了作图清晰整洁，通常应遵循以下两个原则：1. 把交互频繁的对象尽可能的靠拢；2. 把初始化整个交互活动的对象放置在最左端。 3. 生命线（Lifeline）在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。 4. 控制焦点（Focus of Control）又称为激活期，表示时间段的符号，在这个时间段内对象将执行相应的操作。它可以被理解成 C 语言语义中一对花括号{ }中的内容；用小矩形表示。 5. 消息（Message）消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）。 消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义；消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。返回消息表示从过程调用返回。 6. 自关联消息表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。 7. 组合片段组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有 13 种，名称及含义如下： 片段类型 名称 说明 Opt 选项 包含一个可能发生或可能不发生的序列。 可以在临界中指定序列发生的条件。 Alt 抉择 包含一个片段列表，这些片段包含备选消息序列。 在任何场合下只发生一个序列。可以在每个片段中设置一个临界来指示该片段可以运行的条件。 else 的临界指示其他任何临界都不为 True 时应运行的片段。 如果所有临界都为 False 并且没有 else，则不执行任何片段。 Loop 循环 片段重复一定次数。 可以在临界中指示片段重复的条件。Loop 组合片段具有“Min”和“Max”属性，它们指示片段可以重复的最小和最大次数。 默认值是无限制。 Break 中断 如果执行此片段，则放弃序列的其余部分。 可以使用临界来指示发生中断的条件。 Par 并行 并行处理。 片段中的事件可以交错。 Critical 关键 用在 Par 或 Seq 片段中。 指示此片段中的消息不得与其他消息交错。 Seq 弱顺序 有两个或更多操作数片段。 涉及同一生命线的消息必须以片段的顺序发生。 如果消息涉及的生命线不同，来自不同片段的消息可能会并行交错。 Strict 强顺序 有两个或更多操作数片段。 这些片段必须按给定顺序发生。 - - - Consider 考虑 指定此片段描述的消息列表。 其他消息可发生在运行的系统中，但对此描述来说意义不大。在“Messages”属性中键入该列表。 Ignore 忽略 此片段未描述的消息列表。 这些消息可发生在运行的系统中，但对此描述来说意义不大。在“Messages”属性中键入该列表。 Assert 断言 操作数片段指定唯一有效的序列。 通常用在 Consider 或 Ignore 片段中。 Neg 否定 此片段中显示的序列不得发生。 通常用在 Consider 或 Ignore 片段中。 四、时序图的画法及实例 划清边界，识别交互的语境； 将所要绘制的交互场景中的角色以及对象梳理出来； 从触发整个交互的某个消息开始，在生命线之间从上到下依次画出所有消息，并注明每个消息的特性（如参数等）。 具体例子参考：http://www.woshipm.com/ucd/607593.html]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>时序图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2018%2F06%2F10%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[作为一名前端开发者，我们经常会处理各种事件，比如常见的 click、scroll、 resize 等等。仔细一想，会发现像 scroll、输入框 onchange 这类事件会频繁触发，如果我们在回调中计算元素位置、做一些跟 DOM 相关的操作，引起浏览器回流和重绘，频繁触发回调，很可能会造成浏览器掉帧，甚至会使浏览器崩溃，影响用户体验。针对这种现象，目前有两种常用的解决方案：防抖和节流。 1. 防抖（debounce） 所谓防抖，就是指触发事件后，就是把触发非常频繁的事件合并成一次去执行。即在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算。 下面使用 setTimeout 方法尝试实现这个功能： 12345678910const debounce = (fn, delayTime) =&gt; &#123; let timeId; return () =&gt; &#123; const context = this, args = arguments; timeId &amp;&amp; clearTimeout(timeout); timeId = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, delayTime) &#125;&#125; 思路解析： 执行 debounce 函数之后会返回一个新的函数，通过闭包的形式，维护一个变量 timeId ，每次执行该函数的时候会结束之前的延迟操作，重新执行 setTimeout 方法，也就实现了上面所说的指定的时间内多次触发同一个事件，会合并执行一次。 温馨提示： 上述代码中 arguments 只会保存事件回调函数中的参数，譬如：事件对象等，并不会保存 fn 、delayTime 使用 apply 改变传入的 fn 方法中的 this 指向，指向绑定事件的 DOM 元素。 2. 节流（throttle）所谓节流，是指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。 我们使用两种方法来简单实现这种功能：时间戳和 setTimeout 定时器。 时间戳 123456789101112const throttle = (fn, delayTime) =&gt; &#123; let _start = Date.now(); return () =&gt; &#123; const _now = Date.now(), context = this, args = arguments; if(_now - _start &gt;= delayTime) &#123; fn.apply(context, args); _start = Date.now(); &#125; &#125;&#125; 通过比较两次时间戳的间隔是否大于等于我们事先指定的时间来决定是否执行事件回调。 定时器 1234567891011121314const throttle = (fn, delayTime) =&gt; &#123; let flag return () =&gt; &#123; const context = this, args = arguments; if(!flag) &#123; flag = setTimeout(() =&gt; &#123; fn.apply(context, args); flag = false; &#125;, delayTime); &#125; &#125;&#125; 在上述实现过程中，我们设置了一个标志变量 flag ，当 delayTime 之后执行事件回调，便会把这个变量重置，表示一次回调已经执行结束。 对比上述两种实现，我们会发现一个有趣的现象： 1、使用时间戳方式，页面加载的时候就会开始计时，如果页面加载时间大于我们设定的 delayTime ，第一次触发事件回调的时候便会立即 fn ，并不会延迟。如果最后一次触发回调与前一次触发回调的时间差小于 delayTime ，则最后一次触发事件并不会执行 fn ； 2、使用定时器方式，我们第一次触发回调的时候才会开始计时，如果最后一次触发回调事件与前一次时间间隔小于 delayTime ，delayTime 之后仍会执行 fn 。 这两种方式有点优势互补的意思。 我们考虑把这两种方式结合起来，便会在第一次触发事件时执行 fn，最后一次与前一次间隔比较短，delayTime 之后再次执行 fn。 想法简单实现如下： 12345678910111213141516const throttle = (fn, delayTime) =&gt; &#123; let flag, _start = Data.now(); return () =&gt; &#123; const context = this, args = arguments, _now = Date.now(), remainTime = delayTime - (_now - _start); if (remainTime &lt;= 0) &#123; fn.apply(this, args); &#125; else &#123; setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, remainTime); &#125; &#125;&#125; 通过上面的分析，可以很明显的看出函数防抖和函数节流的区别： 频繁触发事件时，函数防抖只会在最后一次触发事件只会才会执行回调内容，其他情况下会重新计算延迟事件，而函数节流便会很有规律的每隔一定时间执行一次回调函数。 3. requestAnimationFrame之前，我们使用 setTimeout 简单实现了防抖和节流功能，如果我们不考虑兼容性，追求精度比较高的页面效果，可以考虑试试 html5 提供的 API – requestAnimationFrame 。 与 setTimeout 相比，requestAnimationFrame 的时间间隔是有系统来决定，保证屏幕刷新一次，回调函数只会执行一次，比如屏幕的刷新频率是 60HZ，即间隔 1000ms / 60 会执行一次回调。 123456789101112const throttle = (fn, delayTime) =&gt; &#123; let flag; return () =&gt; &#123; if (!flag) &#123; requestAnimationFrame(() =&gt; &#123; fn(); flag = false; &#125;); flag = true; &#125; &#125;&#125; 上述代码的基本功能就是保证在屏幕刷新的时候（对于大多数的屏幕来说，大约 16.67ms ），可以执行一次回调函数 fn。使用这种方式也存在一种比较明显的缺点，时间间隔只能跟随系统变化，我们无法修改，但是准确性会比 setTimeout 高一些。 注意： 防抖和节流只是减少了事件回调函数的执行次数，并不会减少事件的触发频率。 防抖和节流并没有从本质上解决性能问题，我们还应该注意优化我们事件回调函数的逻辑功能，避免在回调中执行比较复杂的 DOM 操作，减少浏览器 reflow 和 repaint 。 4. 开源库的实现上面的示例代码比较简单，只是说明了基本的思路。目前已经有工具库实现了这些功能，比如 underscore 、lodash ，考虑的情况也会比较多，大家可以去查看源码，学习作者的思路，加深理解。 underscore lodash underscore 的 debounce 方法源码： 12345678910111213141516171819202122232425262728_.debounce = function(func, wait, immediate) &#123; var timeout, result; var later = function(context, args) &#123; timeout = null; if (args) result = func.apply(context, args); &#125;; var debounced = restArguments(function(args) &#123; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); &#125; else &#123; timeout = _.delay(later, wait, this, args); &#125; return result; &#125;); debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced; &#125;; underscore 的 throttle 源码： 12345678910111213141516171819202122232425262728293031323334353637383940_.throttle = function(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; return throttled;&#125;; 学习链接： 十分钟学会防抖和节流 JS节流防抖函数]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>防抖</tag>
        <tag>节流</tag>
        <tag>lodash</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 常用插件和快捷键]]></title>
    <url>%2F2018%2F06%2F03%2Fvs-code%2F</url>
    <content type="text"><![CDATA[俗话说：工欲善其事， 必先利其器 https://code.visualstudio.com/ 作为我开发的利器，有必要记录下我使用的插件，配置以及快捷键。 1. 快捷键下面列举了一些常用的，具体的可查看： https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf 按键 描述 ctrl + k + s 打开查看键盘快捷方式 ctrl + x 剪切 ctrl + c 复制 ctrl + v 粘贴 ctrl + f 当前文件关键字搜索 Home 光标跳转到行头 End 光标跳转到行尾 ctrl + Home 跳转到页头 ctrl + End 跳转到页尾 ctrl + [ / ] 行 增加 / 减少 缩进 ctrl + / 单行注释 ctrl + / (或 按下ctrl不放，再按 k + u) 取消单行注释 alt + shift + A (或 /** ) 多行注释 alt + up / down 向上 / 向下 移动行 ctrl + b 显示 / 隐藏 左侧目录栏 shift + alt + up / down 向上 / 向下 复制当前行 ctrl + shift + k 删除当前行 ctrl + ~ 显示 / 隐藏 控制台终端 ctrl + P 查找文件 shift + alt + f 代码格式化 ctrl + shift + n 新建一个窗口 ctrl + ( + 或 - ) 字体放大 / 缩小 ctrl + 1 / 2 / 3 拆分编辑器 F11 切换全屏模式 ctrl + N 新建文件 ctrl + o 打开文件 ctrl + s 保存文件 ctrl + shift + s 另存为 ctrl + w 关闭编辑器窗口 ctrl + k + w 关闭所有编辑器窗口 ctrl + shift + T 撤销最近关闭的一个文件编辑窗口 ctrl + shift + F 打开全局搜索 ctrl + shift + X 打开插件市场面板 ctrl + shift + H 在当前文件查询替换 2. 常用插件 https://marketplace.visualstudio.com/vscode 插件 描述 vscode-icon 让 vscode 资源树目录加上图标，必备良品！ ESlint ESlint 接管原生 js 提示，可以自定制提示规则 TSlint ts 文件 代码风格检查， 可以自定义规则 GitLens 丰富的 git 日志插件 Material Theme Visual Studio Code 最悠久的主题！ Auto Close Tag 自动闭合标签 Auto Import 自动去查找、分析、然后提供代码补全。对于 TypeScript 和 TSX，可以适用。 Auto Rename Tag 修改 html 标签，自动帮你完成尾部闭合标签的同步修改，不过有些 bug 。 Color Highlight 文档中的 css / web 颜色样式 Code Spell Checker 单词拼写检查 Chinese (Simplified) Language Pack for Visual Studio Code 为 VS Code 提供本地化界面 Bracket Pair Colorizer 让括号拥有独立的颜色，易于区分。可以配合任意主题使用。 Git History 查看 git 提交历史 Import Cost 该插件会在行尾显示导入的包的大小。为了计算包大小，该插件要使用 Webpack 和 babili-webpack-plugin。 Prettier 一键美化你的 JavaScript / TypeScript / CSS 代码。 React Native Tools 代码提示、Debugging、集成 RN 的命令。 Snippet 常用代码片段，支持自定义（例如 React Native Snippet） TODO Highlight 会在还有 TODO: / FIXME: 的地方出现高亮提示 Sublime Text Keymap and Settings Importer 将 visual studio code 的快捷键绑定改成了和 Sublime Text 3 一样。你可以试一试：cmd + P (Mac)，ctrl + P (Windows)。 Quokka.js 实时执行 JavaScript 代码(做快速的 demo 很有用)。 Trailing Spaces 高亮那些冗余的空格，可以快速删掉。 TypeScript Hero 辅助用 TypeScript 编程的童鞋！ Sort Typescript imports TypeScript import 排序 Vetur VS Code 下面的 Vue 工具！ Code Runner 支持多种语言的代码的立即执行 React.js code snippets 用 ES6 语法去开发 React.js 应用非常方便。 filesize 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间 WakaTime 根据编程活动自动生成度量标准，代码检测和时间跟踪。（长时间的需要收费） Npm Intellisense 用于在 import 语句中自动填充 npm 模块。 REST Client REST 客户端允许您直接发送 HTTP 请求并在 Visual Studio 代码中查看响应。 Markdownlint markdown 文件格式检查 Settings Sync 重点介绍下这个插件，如果你有两台电脑（比如，家里和公司）都使用 VS Code ，可是在公司或家里对 VS Code 安装了插件或者修改了配置，回到家或公司又要重新弄一次，这个插件就能解决问题，同步多台电脑设置。 还有很多其他有趣使用的插件，这里暂不列举了。。。。。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vs-code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2 介绍及常用命令]]></title>
    <url>%2F2018%2F05%2F27%2Fpm2%2F</url>
    <content type="text"><![CDATA[pm2 官方网站： http://pm2.keymetrics.io/ pm2 中文文档： https://pm2.io/doc/zh/runtime/quick-start/ pm2 是一个带有负载均衡功能的 Node 应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有 CPU ,并保证进程永远都活着,0 秒的重载, PM2 是完美的,下面我们来看 pm2 常用的命令用法介绍吧。 PM2 （github上的源码）是开源的基于Nodejs的进程管理器，包括守护进程，监控，日志的一整套完整的功能，基本是 Nodejs 应用程序不二的守护进程选择，事实上它并不仅仅可以启动 Nodejs 的程序，只要是一般的脚本的程序它同样可以胜任。 以下是pm2常用的命令行： 命令 描述 # pm2 start app.js 启动app.js应用程序 # pm2 start app.js -i 4 cluster mode 模式启动 4 个app.js的应用实例（4 个应用程序会自动进行负载均衡） # pm2 start app.js –name=”api” 启动应用程序并命名为 “api” # pm2 start app.js –watch 当文件变化时自动重启应用 # pm2 start script.sh 启动 bash 脚本 # pm2 list 列表 PM2 启动的所有的应用程序 # pm2 monit 显示每个应用程序的 CPU 和内存占用情况 # pm2 show [app-name] 显示应用程序的所有信息 # pm2 logs 显示所有应用程序的日志 # pm2 logs [app-name] 显示指定应用程序的日志 # pm2 stop all 停止所有的应用程序 # pm2 stop 0 停止 id 为 0 的指定应用程序 # pm2 restart all 重启所有应用 # pm2 reload all 重启 cluster mode 下的所有应用 # pm2 delete all 关闭并删除所有应用 # pm2 delete 0 删除指定应用 id 0 # pm2 scale api 10 把名字叫 api 的应用扩展到 10 个实例 # pm2 reset [app-name] 重置重启数量 # pm2 startup 创建开机自启动命令 # pm2 save 保存当前应用列表 # pm2 resurrect 重新加载保存的应用列表]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所了解的 EventEmitter]]></title>
    <url>%2F2018%2F05%2F20%2Fnode-EventEmitter%2F</url>
    <content type="text"><![CDATA[1. Events 模块介绍 node 的特性：单线程 异步 非阻塞 I/O 基于事件驱动的运行在服务器端轻量、高效的脚本语言； Events 模块是 nodejs 的核心模块，是 node 实现事件驱动的基础，node 中几乎所有的模块(如 http, fs 等)都继承该模块； 1234const fs = require('fs');const EventEmitter = require('events');var stream = fs.createReadStream('./a.js');console.log(stream instanceof EventEmitter); // true Events 模块实现了事件注册，通知等功能，是观察者模式（事件发布/订阅模式）的实现； 只要继承 EventEmitter 类，就可拥有事件注册、触发事件等，所有能触发事件的对象都是 EventEmitter 类的实例, 例如： net.Server 对象会在每次有新连接时触发事件； fs.ReadStream 会在文件被打开时触发事件； 流对象 会在数据可读时触发事件； 2. 相关 API 导入模块（创建emitter实例） 1const EE = require(&apos;events&apos;); // events 模块只提供了一个EventEmitter 类,所以返回的就是 EventEmitter 注册绑定事件 12345678910// 相当于增加观察者，addListener 和 on 这两个方式作用是一样的, addListener 是 on 方法的别名EE.addListener(event, listener);EE.on(event, listener);// 绑定的事件监听器只会执行一次，然后就会被删除掉EE.once(event, listener);// 添加了任意的监听函数时会触发newListenerEE.on(&apos;newListener&apos;, (type, listener) =&gt; &#123;&#125;); 触发事件 1EE.emit(event); 移除事件 12345// 移除事件 event 的监听函数 listenerEE.removeListener(event, listener); // 移除所有EE.removeAllListeners([event]); 其它api 123456// 设置同一事件的监听器最大绑定数，默认情况下，超过 10 个就会警告；设置为 0，是无限制；EE.setMaxListeners(n);// 查看事件监听器数量 EE.listenerCount();.......更多查看官网 3. EventEmitter 接口的部署EventEmitter 接口可以部署在任意对象上，使得这些对象也能订阅和发布消息。 直接继承 EventEmitter类 Node 内置模块 util 的 inherits 方法，实现继承 12345678910111213141516171819202122232425eg1: 借助util模块 let EventEmitter = require(&apos;events&apos;); let util = require(&apos;util&apos;); function WriteStream () &#123; EventEmitter.call(this); // 继承私有属性 &#125; util.inherits(WriteStream, EventEmitter); //原型继承，继承公有 /** * 定义一个WriteStream类，把EventEmitter类的方法添加到新创建的WriteStream 类中，使WriteStream的实例具有EventEmitter的方法。 * 相当于： * Object.setPrototypeOf(ctor.prototype, superCtor.prototype); //指定的对象的原型 * ctor.prototype.__proto__ = superCtor.prototype; */ eg2: 借助es6 extends方法 const EventEmitter = require(&apos;events&apos;); class MyEmitter extends EventEmitter &#123;&#125; const myEmitter = new MyEmitter(); myEmitter.on(&apos;event&apos;, () &#123; console.log(&apos;触发了一个事件了&apos;)； &#125;); myEmitter.emit(&apos;event&apos;); //触发事件 当我们订阅了&apos;event&apos;事件后，可以在任何地方通过emit(&apos;event&apos;)来执行事件回调； 4. 异常处理由于监听函数的执行是同步执行的，所以针对同步的代码可以通过try catch捕获到。123456789101112131415161718192021222324252627const EventEmitter = require(&apos;events&apos;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, function() &#123; a.b(); console.log(&apos;listener1&apos;);&#125;);myEmitter.on(&apos;event&apos;, async function() &#123; console.log(&apos;listener2&apos;); await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000); &#125;);&#125;);myEmitter.on(&apos;event&apos;, function() &#123; console.log(&apos;listener3&apos;);&#125;);try &#123; myEmitter.emit(&apos;event&apos;);&#125; catch(e) &#123; console.error(&apos;err&apos;);&#125;console.log(&apos;end&apos;);// 输出结果enderr 但是如果把a.b();移到第二个listener里面的话就会出现下面的问题1234567891011121314151617181920212223242526272829303132const EventEmitter = require(&apos;events&apos;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, function() &#123; console.log(&apos;listener1&apos;);&#125;);myEmitter.on(&apos;event&apos;, async function() &#123; console.log(&apos;listener2&apos;); a.b(); await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000); &#125;);&#125;);myEmitter.on(&apos;event&apos;, function() &#123; console.log(&apos;listener3&apos;);&#125;);try &#123; myEmitter.emit(&apos;event&apos;);&#125; catch(e) &#123; console.error(&apos;err&apos;);&#125;console.log(&apos;end&apos;);// 输出结果listener1listener2listener3end(node:9046) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): ReferenceError: a is not defined(node:9046) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code async 函数的特点就在于它的返回值是一个 Promise，如果函数体内出现错误的话 Promise 就是 reject 状态。Node.js 不推荐忽略 reject 的 promise，而 EventEmitter 对于各监听函数的返回值是忽略的，所以才会出现上面的情况。明白了问题的原因后我们就可以确定对于上面的情况的话，需要在第二个 listener 里面增加 try catch 的处理。 当事件被触发时，如果没有与该事件绑定的函数的话，该事件会被静默忽略掉，但是如果事件的名称是 error 的话，没有与此相关的事件处理的话，程序就会 crash 退出1234567891011121314151617181920212223const EventEmitter = require(&apos;events&apos;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, function(data) &#123; console.log(data);&#125;);myEmitter.emit(&apos;error&apos;);events.js:199 throw err; ^Error [ERR_UNHANDLED_ERROR]: Unhandled error. at MyEmitter.emit (events.js:197:19) at Object.&lt;anonymous&gt; (/Users/xiji/workspace/learn/event-emitter/b.js:7:11) at Module._compile (module.js:641:30) at Object.Module._extensions..js (module.js:652:10) at Module.load (module.js:560:32) at tryModuleLoad (module.js:503:12) at Function.Module._load (module.js:495:3) at Function.Module.runMain (module.js:682:10) at startup (bootstrap_node.js:191:16) at bootstrap_node.js:613:3 只有添加了针对 error 事件的处理函数的话程序才不会退出了。 另外一种方式是 process 监听 uncaughtException 事件，但是这并不是推荐的做法，因为 uncaughtException 事件是非常严重的，通常情况下在 uncaughtException 的处理函数里面一般是做一些上报或者清理工作，然后执行 process.exit(1) 让程序退出了。12345678910process.on(&apos;uncaughtException&apos;, function(err) &#123; console.error(&apos;uncaught exception:&apos;, err.stack || err); // orderly close server, resources, etc. closeEverything(function(err) &#123; if (err) console.error(&apos;Error while closing everything:&apos;, err.stack || err); // exit anyway process.exit(1); &#125;);&#125;); 5. 监听函数的执行顺序除了 on 的方式（向后追加），我们还可以使用 prependListene r的方法来（向前插入）增加监听函数12345678910111213141516171819const EventEmitter = require(&apos;events&apos;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();myEmitter.prependListener(&apos;event&apos;, function() &#123; console.log(&apos;listener1&apos;);&#125;);myEmitter.prependListener(&apos;event&apos;, async function() &#123; console.log(&apos;listener2&apos;);&#125;);myEmitter.prependListener(&apos;event&apos;, function() &#123; console.log(&apos;listener3&apos;);&#125;);myEmitter.emit(&apos;event&apos;);console.log(&apos;end&apos;);// 输出结果listener3listener2listener1end 6. this 指向监听函数如果采用如下写法的话，那么 this 的指向就是事件的 emitter1234567const EventEmitter = require(&apos;events&apos;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, function(a, b) &#123; console.log(a, b, this === myEmitter); // a b true&#125;);myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;); 如果是用箭头函数写法的话，那么 this 就不是指向 emitter 了1234567const EventEmitter = require(&apos;events&apos;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, (a, b) =&gt; &#123; console.log(a, b, this === myEmitter); // a b false&#125;);myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;); 7. 简单实现一个自己的 myEventEmitter 库首先实现这个 myEventEmitter 库,需要先对观察者模式进行了解，这样写起来才会得心应手； 观察者模式是管理消息分发的一种方式，这种模式中，发布消息的一方不需要知道这个消息会给谁，而订阅一方也无需知道消息的来源。 简单原理描述：this.events 维护一个信号对应函数的列表,通过这个索引，可以对这个信号进行增、删等操作，你只需要按照这个信号执行对象的回调函数；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyEvents &#123; constructor () &#123; this.events = &#123;&#125; //存储事件监听函数 this.maxListeners = 10 //一种函数类型，最大监听函数数量 &#125; setMaxListeners (maxNum) &#123; this.maxListeners = maxNum &#125; getMaxListeners () &#123; return this.maxListeners &#125; listeners (event) &#123; return this.events[event] &#125; addListener (type, listener) &#123; if (this.events[type]) &#123; if (this.maxListeners != 0 &amp;&amp; this.events[type].length &gt; this.maxListeners) &#123; return console.error(`该$&#123;type&#125;事件类型的listteners超出限制，使用emitter.setMaxListeners() 来增加添加事件监听数量。`) &#125; this.events[type].push(listener) &#125; else &#123; this.events[type] = [listener] &#125; &#125; once (type, listener) &#123; //执行后立即销毁 let wrapper = (...rest) =&gt; &#123; listener.apply(this, rest) this.removeListener(type, wrapper) &#125; this.addListener(type, wrapper) &#125; removeListener (type, listener) &#123; if (this.events[type]) &#123; this.events[type] = this.events[type].filter(ev =&gt; &#123; ev != listener &#125;) //抛弃掉等于listener的 &#125; &#125; removeAllListener (type) &#123; delete this.events[type] &#125; emit (type, ...rest) &#123; this.events[type] &amp;&amp; this.events[type].forEach(listener =&gt; &#123; listener.apply(this, rest) &#125;) &#125;&#125;MyEvents.prototype.on = MyEvents.prototype.addListenermodule.exports = MyEvents 学习链接： http://javascript.ruanyifeng.com/nodejs/events.html https://juejin.im/post/5b0189fe51882567161ad8ef https://juejin.im/post/5a6ebc056fb9a01ca072172b https://nodejs.org/api/events.html]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
        <tag>event emitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 介绍及常用命令]]></title>
    <url>%2F2018%2F05%2F13%2Fgit%2F</url>
    <content type="text"><![CDATA[git官网：https://git-scm.com/ 常用 git 命令清单： http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html git 常用命令速查表：https://www.w3cschool.cn/git/git-cheat-sheet.html git 的奇技淫巧： https://github.com/521xueweihan/git-tips]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 常用命令]]></title>
    <url>%2F2018%2F05%2F06%2Fcentos-7%2F</url>
    <content type="text"><![CDATA[最近搭建 node 服务开始接触到云服务器，使用的是 CentOS 7 ，于是整理一下常用的命令。 这里约定的以 # 开头为一个命令，服务器操作时，去掉 # 。 常用命令: 文件和目录: 命令 描述 # cd /home 进入 ‘/home’ 目录 # cd .. 返回上两级目录 # cd ../.. 返回上两级目录 # cd - 返回上次所在目录 # cp file1 file2 将file1复制为file2 # cp -a /tmp/dir1 . 复制一个目录到当前工作目录（.代表当前目录） # ls 查看目录中的文件 # ls -a 显示隐藏文件 # ls -l 显示详细信息 # ls -lrt 按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序） # pwd 显示工作路径 # mkdir dir1 创建 ‘dir1’ 目录 # mkdir dir1 dir2 同时创建两个目录 # mkdir -p /tmp/dir1/dir2 创建一个目录树 # rm -f file1 删除 ‘file1’ # rm -rf dir1 删除 ‘dir1’ 目录及其子目录内容 # touch test.txt 在当前目录创建 test.txt 文件 # touch test1.txt test2.txt 创建多个文件 # stat test.txt 查看访问修改文件的时间 # touch -a test.txt 修改访问时间 # touch -d ‘18-May-2017’ test.txt 更改为自定义格式、自定义时间戳（更改访问时间、修改时间） # touch -m test.txt 更改修改时间 # touch -r test1.txt test2.txt 修改 test1.txt 为 test2.txt 文件的时间戳。 # touch -t 201703031558.28 test.txt 更改为自定义时间戳 # mv test1 test2 将目录 test1 改为 test2 # mv /test1 /home/test2 将 /test1 目录移动到 /home/ 下，并重命名为 test2 # mv test1.txt test2.txt 将文件 test1.txt 改为 test2.txt 查看文件内容： 命令 描述 # cat file1 从第一个字节开始正向查看文件的内容 # head -2 file1 查看一个文件的前两行 # more file1 查看一个长文件的内容 # tac file1 从最后一行开始反向查看一个文件的内容 # tail -3 file1 查看一个文件的最后三行 文本处理： 命令 描述 # grep str /home/test.js 在文件 ‘/home/test.js’ 中查找 “str”(区分大小写) # grep ^str /home/test.js 在文件 ‘/home/test.js’ 中查找以 “str” 开始的行 # grep [0-9] /home/test.js 查找 ‘/home/test.js’ 文件中所有包含数字的行 # grep str -r /home/* 在目录 ‘/home’ 及其子目录中查找 “str” # diff file1 file2 找出两个文件的不同处 # sdiff file1 file2 以对比的方式显示两个文件的不同 查找： 命令 描述 # find / -name file1 从 ‘/‘ 开始进入根文件系统查找文件和目录 # find / -user user1 查找属于用户 ‘user1’ 的文件和目录 # find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件 # find /usr/bin -type f -atime +100 查找在过去100天内未被使用过的执行文件 # find /usr/bin -type f -mtime -10 查找在10天内被创建或者修改过的文件 # locate *.ps 寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令 # find -name ‘*.[ch]’ &#124; xargs grep -E ‘expr’ 在当前目录及其子目录所有.c和.h文件中查找 ‘expr’ # find -type f -print0 &#124; xargs -r0 grep -F ‘expr’ 在当前目录及其子目录的常规文件中查找 ‘expr’ # find -maxdepth 1 -type f &#124; xargs grep -F ‘expr’ 在当前目录中查找 ‘expr’ 注意whereis： whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 命令格式：whereis [-bmsu] [BMS 目录名 -f ] 文件名-和 find 相比，whereis 查找的速度非常快，这是因为 linux 系统会将 系统内的所有文件都记录在一个数据库文件中，当使用 whereis 和 locate 时，会从数据库中查找数据，而不是像 find 命令那样，通过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用 whereis 和 locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 压缩和解压: 命令 描述 # bzip2 file1 压缩 file1 # bunzip2 file1.bz2 解压 file1.bz2 # gzip file1 压缩 file1 # gzip -9 file1 最大程度压缩 file1 # gunzip file1.gz 解压 file1.gz # tar -cvf archive.tar file1 把 file1 打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数） # tar -cvf archive.tar file1 dir1 把 file1，dir1 打包成 archive.tar # tar -tf archive.tar 显示一个包中的内容 # tar -xvf archive.tar 释放一个包 # tar -xvf archive.tar -C /tmp 把压缩包释放到 /tmp目录下 # zip file1.zip file1 创建一个zip格式的压缩包 # zip -r file1.zip file1 dir1 把文件和目录压缩成一个zip格式的压缩包 # unzip file1.zip 解压一个zip格式的压缩包到当前目录 # unzip test.zip -d /tmp/ 解压一个zip格式的压缩包到 /tmp 目录 yum工具: 命令 描述 # yum -y install [package] 下载并安装一个rpm包 # yum localinstall [package.rpm] 安装一个rpm包，使用你自己的软件仓库解决所有依赖关系 # yum -y update 更新当前系统中安装的所有rpm包 # yum update [package] 更新一个rpm包 # yum remove [package] 删除一个rpm包 # yum list 列出当前系统中安装的所有包 # yum search [package] 在rpm仓库中搜寻软件包 # yum clean [package] 清除缓存目录（/var/cache/yum）下的软件包 # yum clean headers 删除所有头文件 # yum clean all 删除所有缓存的包和头文件 网络: 命令 描述 # ifconfig eth0 显示一个以太网卡的配置 # ifconfig eth0 192.168.1.1 netmask 255.255.255.0 配置网卡的IP地址 # ifdown eth0 禁用 ‘eth0’ 网络设备 # ifup eth0 启用 ‘eth0’ 网络设备 # iwconfig eth1 显示一个无线网卡的配置 # iwlist scan 显示无线网络 # ip addr show 显示网卡的IP地址 其他: 命令 描述 # su - 切换到root权限（与su有区别） # shutdown -h now 关机 # shutdown -r now 重启 # top 罗列使用 CPU 资源最多的 linux 任务 （输入 q 退出） # pstree 以树状图显示程序 # man ping 查看参考手册（例如 ping 命令） # passwd 修改密码 # df -h 显示磁盘的使用情况 # cal -3 显示前一个月，当前月以及下一个月的月历 # cal 10 1988 显示指定月，年的月历 # date –date ‘1970-01-01 UTC 1427888888 seconds’ 把一相对于1970-01-01 00:00的秒数转换成时间 # ps -ef &#124; grep nginx 查看 nginx 安装路径 操作： 按键 描述 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于 Ctrl + Break Ctrl + a 光标移动到行首（ahead of line），相当于通常的 Home 键 Ctrl + e 光标移动到行尾（end of line） Ctrl + f 光标向前（forward）移动一个字符位置 Ctrl + b 光标往回（backward）移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + r 显示:号提示，根据用户输入查找相关历史命令（reverse-i-search） Ctrl + w 删除从光标位置前到当前所处单词（word）的开头 Ctrl + t 交换光标位置前的两个字符 Ctrl + y 粘贴最后一次被删除的单词 Ctrl + Alt + d 显示桌面 Alt + b 光标往回（backward）移动到前一个单词 Alt + d 删除从光标位置到当前所处单词的末尾 Alt + F2 运行 Alt + F4 关闭当前窗口 Alt + F9 最小化当前窗口 Alt + F10 最大化当前窗口 Alt + Tab 切换窗口 [鼠标中间键] 粘贴突出显示的文本。使用鼠标左键来选择文本。把光标指向想粘贴文本的地方。点击鼠标中间键来粘贴。 [Tab] 命令行自动补全。 systemctl 命令： 命令 描述 # systemctl enable *.service 开机运行服务 # systemctl disable *.service 取消开机运行 # systemctl start *.service 启动服务 # systemctl stop *.service 停止服务 # systemctl restart *.service 重启服务 # systemctl reload *.service 重新加载服务配置文件 # systemctl status *.service 查询服务运行状态 # systemctl –failed 显示启动失败的服务 防火墙命令: 命令 描述 # firewall-cmd –version 查看版本 # firewall-cmd –help 查看帮助 # firewall-cmd –state 显示状态 # firewall-cmd –list-port 查看端口 # firewall-cmd –add-port=80/tcp –permanent 开放端口 # firewall-cmd –add-port=20000-20010/tcp –permanent 开放端口(参数 –permanent，表示永久生效) # firewall-cmd –remove-port=80/tcp –permanent 禁用端口 # firewall-cmd –remove-port=20000-20010/tcp –permanent 禁用端口(参数 –permanent，表示永久生效) # firewall-cmd –reload 重新加载防火墙规则 # firewall-cmd –add-service=ftp –permanent 打开FTP服务 # firewall-cmd –remove-service=ftp –permanent 关闭FTP服务(参数 –permanent，表示永久生效) vi 编辑命令： # vi /home/test.txt 用 vi 打开一个 test.txt 文件 按 i 键后 进入insert模式（进入 insert 模式后才能进行修改） # 修改完成后，按 esc 键进入 command 模式，然后 :wq 保存文件并退出 vi（注意先冒号） 保存命令（按 ESC 键 跳到命令模式，然后：） :w ———– 保存文件但不退出 vi :w file ——— 将修改另外保存到 file 中，不退出vi :w! ——– 强制保存，不推出vi :wq ——– 保存文件并退出vi :wq! ——- 强制保存文件，并退出vi q: ——— 不保存文件，退出vi :q! ———- 不保存文件，强制退出vi :e! ———- 放弃所有修改，从上次保存文件开始再编辑 vi具体可参考： http://www.mamicode.com/info-detail-2037716.html Centos 、Ubuntu、Debian 三个 Linux 介绍Centos 、Ubuntu、Debian 三个Linux都是非常优秀的系统，开源的系统，也分付费的商业版和免费版，下面简单比较这三种系统。 Centos 系统 非常多的商业公司部署在生产环境上的服务器都是使用 CentOS 系统，Centos 是从 Redhat 源代码编译重新发布版，Centos 去除很多与服务器功能无关的应用，系统简单但非常稳定，命令行操作可以方便管理系统和应用，并且有帮助文档和社区的支持。 Ubuntu 系统 Ubuntu 系统有着靓丽的用户界面，完善的包管理系统，强大的软件源支持，丰富的技术社区，并且 Ubuntu 对计算机硬件的支持优于 centos 和 Debian ，兼容性强，Ubuntu 应用非常多，但是对于服务器操作系统来说，并不需要太多的应用程序，需要的是稳定，操作方便，维护简单的系统。如果你需要在服务器端使用图形界面，Ubuntu是一个不错的选择，你需要注意的是，图形界面占用的内存非常大，而内存越大的 vps 价格也越高。 Debian 系统 Debian 系统也非常适合做服务器操作系统，与 Ubuntu 比较，它没有太多的花哨，稳定压倒一切，对于服务器操作系统来说是一条不变的真理，Debian 这个Linux 系统，底层非常稳定，内核和内存的占用都非常小，在小内存的 vps 就可以顺畅运行 Debian ,比如 128M 的内存，但 Debian 的帮助文档和技术资料比较少，对于小内存，首选 Debian，对于非常熟悉 Linux 系统的 vps 高手，首选Debian。 centos 目录介绍 目录 描述 /bin 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。 /etc 存放系统管理和配置文件 /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是 /home/user，可以用 ~user 表示 /usr 用于存放系统应用程序，比较重要的目录- /usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。- /usr/x11r6 存放 x window 的目录- /usr/bin 众多的应用程序- /usr/sbin 超级用户的一些管理程序- /usr/doc linux 文档- /usr/include linux下开发和编译应用程序所需要的头文件- /usr/lib 常用的动态链接库和软件包的配置文件- /usr/man 帮助文档- /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里- /usr/local/bin 本地增加的命令- /usr/local/lib 本地增加的库 /opt 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。 /proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /root 超级用户（系统管理员）的主目录（特权阶级^o^） /sbin 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。 /dev 用于存放设备文件。 /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。 /boot 存放用于系统引导时使用的各种文件 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。 /tmp 用于存放各种临时文件，是公用的临时文件存储点。 /var 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。 /lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里 参考链接： https://juejin.im/post/5c9319c2e51d450d597ea3ff https://www.centos.org/]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
        <tag>Linus</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-mongodb上手指南]]></title>
    <url>%2F2018%2F04%2F29%2FNODE_MONGO%2F</url>
    <content type="text"><![CDATA[目录: 12345678910111213141516171819202122232425262728293031321. MongoDB介绍2. MongoDB本地安装3. MongoDB本地操作 3.1 库操作 3.2 表操作4. node-mongodb安装5. node-mongodb连接6. node-mongodb语法和执行 - 插入 - 查询 - 修改 - 删除 - 存储过程7. node-mongoose介绍和使用 7.1 mongoose名词介绍 7.3 node-mongoose安装 7.4 node-mongoose语法和执行 7.4.1 Schema,Modal创建 - 索引和默认值 - 验证器 7.4.2 数据库操作 - 插入 - 删除 - 修改 - 修改器和更新器 - 查询 - 条件查询 - 数量查询 - 根据id查询 - 分页查询 - aggregate8. 其他 1.mongodb介绍 开源，高性能的NoSQL数据库；支持索引、集群、复制和故障转移、各种语言的驱动程序；高伸缩性； 2. mongodb本地安装官方安装说明： http://docs.mongodb.org/manual/tutorial/install-mongodb-on-windows/ 安装成功后启动：我本地是：mongod –dbpath “f:\data\db” MongoDB默认端口是27017; 3. mongodb本地操作成功启动MongoDB后，再打开一个命令行窗口输入mongo，就可以进行数据库的一些操作 a. 库操作新建数据库：第一步：use 新建数据库名；第二步：进行此库相关的操作；如果不进行第二步，该数据库不会被创建 查看数据库：show dbs; 新建表：db.createCollection(‘要新建的表名’); 查看当前数据库下表： show collections; 删除当前数据库指定表：db.表名.drop(); 删除当前数据库：db.dropDatabase(); 提示： 默认为存在“admin”和“local”两个数据库；admin数据库是存放管理员信息的数据库，认证会用到；local是存放replication相关的数据；这两处本篇都没有涉及到； find();是个查询操作，后面会讲到，上面用到主要是为了演示use不存在的库后，进行相关操作会创建出这个库； MongoDB没有像MySQL或MSSQL等数据库这么严格的规定，不是非得要先建库、建表、建各种字段，以后的操作中慢慢的会体会到^_^！ b. 表操作1. 插入方法一：db.表名.insert(数据); 没有去创建新表，其实通过插入操作也会自动创建 _id，是mongodb自已生成的，每行数据都会存在，默认是ObjectId，可以在插入数据时插入这个键的值(支持mongodb支持的所有数据类型) 方法二：db.表名.save(数据); save也可达到insert一样的插入效果 _id可以自已插入 一个表中不一定要字段都相同 那它们有什么区别? 虽然insert和save方法都可以插入数据，当默认的“_id”值已存在时，调用insert方法插入会报错；而save方法不会,会更新相同的_id所在行数据的信息 2. 查询 查询表中所有数据：db.表名.find(); 按条件查询（支持多条件）：db.表名.find(条件); 查询第一条（支持条件）：db.表名.findOne(条件); 限制数量：db.表名.find().limit(数量); 跳过指定数量：db.表名.find().skip(数量); 查询不止这些，还有些高级查询，自行去了解一下^_^! 3. 修改 前面save在_id字段已存在是就是修改操作，按指定条件修改语法如下： db.表名.update({“条件字段名”:”字段值”},{$set:{“要修改的字段名”:”修改后的字段值”}}); 4. 删除 db.表名.remove(条件); 5. 存储过程 12345678 // 创建存储过程： db.system.js.save(&#123;_id:"存储过程ID", value:function(参数)&#123; -- 逻辑主体; return 返回; &#125;&#125;); // 调用存储过程db.eval("存储过程ID()"); 所有存储过程都存放在db.system.js中 4. node-mongodb安装 npm install mongodb 5. node-mongodb连接 创建连接对象，需要传入连接数据库的一些连接参数 123456789101112const mongodbClient = require('mongodb').MongoClient;const url = 'mongodb://locolhost:27017';const dbName = 'test'; // 数据库名称mongodbClient.connect(url, function(err, client)&#123; console.log('连接成功!'); const db = client.db(dbName); const collection = db.collection('test'); // 连接到表 // 执行mongo语句 ...... client.close(); // 关闭连接 &#125;) 关闭连接 关闭一个连接使用close(); 6. node-mongodb语法和执行a. 插入12345678910111213141516171819 const insertData = function(collection, callback) &#123; //插入数据 const data = [&#123;"name":'zhangsan',"age":21&#125;,&#123;"name":'lisi',"age":22&#125;]; collection.insert(data, function(err, result) &#123; if(err)&#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;); &#125; mongodbClient.connect(url, function(err, client)&#123; console.log('连接成功!'); const db = client.db(dbName); const collection = db.collection('test'); insertData(collection, function(result)&#123; console.log(result); &#125;);&#125;) b. 查询123456789101112131415161718192021 const selectData = function(collection, callback) &#123; // 查询所有 let whereStr = &#123;"name":"张三"&#125;; collection.find(whereStr).toArray(function(err, result) &#123; if(err)&#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;); // 条件查询 查询参数很多，自行查阅 collection.find(&#123;"age":&#123;$gt:30&#125;&#125;).toArray(function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;); &#125;...... c. 修改1234567891011 const updateData = function(collection, callback) &#123; const whereStr = &#123;"name":'zhangsan'&#125;; const updateStr = &#123;$set: &#123; "age" : 100 &#125;&#125;; collection.update(whereStr, updateStr, function(err, result) &#123; if(err)&#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; d: 删除1234567891011121314 var delData = function(db, callback) &#123; //连接到表 var collection = db.collection('tb2'); //删除数据 var whereStr = &#123;"name":'wilson001'&#125;; collection.remove(whereStr, function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; e: 存储过程12345678910 const invokeProcData = function(db, callback) &#123; db.eval('get_tb2_count()', function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; 7. mongoose介绍和使用一般我们不直接用MongoDB的函数来操作MongoDB数据库,针对它的进行再次封装的东西很多，且更利于编程实现，比如：mongoose、mongoskin、mongolian等等，应用性不错；Mongoose就是一套操作MongoDB数据库的接口，且应用较多。 1. 名词解释 Schema： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力 Schema.Type：是由Mongoose内定的一些数据类型，基本数据类型都在其中，他也内置了一些Mongoose特有的Schema.Type。当然，你也可以自定义Schema.Type，只有满足Schema.Type的类型才能定义在Schema内。NodeJS中的基本数据类型都属于Schema.Type，另外Mongoose还定义了自己的类型 // 从官网截取过来的，举例： var ExampleSchema = new Schema({ name:String, binary:Buffer, living:Boolean, updated:Date, age:Number, mixed:Schema.Types.Mixed, //该混合类型等同于nested _id:Schema.Types.ObjectId, //主键 _fk:Schema.Types.ObjectId, //外键 array:[], arrOfString:[String], arrOfNumber:[Number], arrOfDate:[Date], arrOfBuffer:[Buffer], arrOfBoolean:[Boolean], arrOfMixed:[Schema.Types.Mixed], arrOfObjectId:[Schema.Types.ObjectId] nested:{ stuff:String, } }); Model： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对 Entity： 由Model创建的实体，他的操作也会影响数据库 Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性 2. node-mongoose安装npm install mongoose 3. 连接mongoose创建一个文件db.js： 12345678910111213141516171819202122const mongoose = require('mongoose'), DB_URL = 'mongodb://localhost:27017/test';// 若有密码，则url：mongodb://username:password@host:port/database?options...'// 连接mongoose.connect(DB_URL);// 连接成功mongoose.connection.on('connected', function () &#123; console.log('Mongoose connection open to ' + DB_URL);&#125;);// 连接异常mongoose.connection.on('error',function (err) &#123; console.log('Mongoose connection error: ' + err);&#125;);// 连接断开mongoose.connection.on('disconnected', function () &#123; console.log('Mongoose connection disconnected');&#125;);module.exports = mongoose; 4. mongoose使用举例，创建了一个用户登录信息表，对此数据进行增删改查 创建文件user.js, 创建Schema，Model 123456789101112131415const mongoose = require('./db.js'), Schema = mongoose.Schema;const UserSchema = new Schema(&#123; username : &#123; type: String, index: true &#125;, //用户账号 userpwd: &#123; type: String, required: true &#125;, //密码 userage: &#123;type: Number, min: 18, max 80 &#125;, //年龄 logindate : &#123; type: Date, default: new Date()&#125;, //最近登录时间 city:&#123; type:'String', enum:['北京','上海'] &#125;, // 城市 other:&#123; type:'String', validate:[validator,err] //validator是一个验证函数，err是验证失败的错误信息 &#125;&#125;);module.exports = mongoose.model('User',UserSchema); 上面有提到几个定义 索引和默认值，即 index和default 验证器，即 required 非空验证 min/max 范围验证（边值验证） enum/match 枚举验证/匹配验证 validate 自定义验证规则 进行数据库操作 a. 插入 12345678910111213141516171819 const User = require("./user.js"); function insert() &#123; const user = new User(&#123; username : 'zhangsan', userpwd: 'abcd', userage: 37, logindate : new Date() &#125;); user.save(function (err, res) &#123; if (err) &#123; console.log("Error:" + err); &#125; else &#123; console.log("Res:" + res); &#125; &#125;); &#125;insert(); b. 修改 123456789101112131415const User = require("./user.js");function update()&#123; const wherestr = &#123;'username' : 'zhangsan McGrady'&#125;; const updatestr = &#123;'userpwd': 'zzzz'&#125;; User.update(wherestr, updatestr, function(err, res)&#123; if (err) &#123; console.log("Error:" + err); &#125; else &#123; console.log("Res:" + res); &#125; &#125;)&#125;update(); 修改器和更新器:为了更快进行更新的操作。在update中需要写很多选择器 12345678910111213141516171819202122232425262728293031$inc增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增1Model.update(&#123;‘age’:22&#125;, &#123;‘$inc’:&#123;‘age’:1&#125; &#125; );执行后: age=23$set指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型Model.update(&#123;‘age’:22&#125;, &#123;‘$set’:&#123;‘age’:’haha’&#125; &#125; );执行后: age=’haha’$unset同上取反,删除一个键Model.update(&#123;‘age’:22&#125;, &#123;‘$unset’:&#123;‘age’:’haha’&#125; &#125; );执行后: age键不存在$push给一个键push一个数组成员,键不存在会创建Model.update(&#123;‘age’:22&#125;, &#123;‘$push’:&#123;‘array’:10&#125; &#125; );执行后: 增加一个 array 键,类型为数组, 有一个成员 10$addToSet向数组中添加一个元素,如果存在就不添加Model.update(&#123;‘age’:22&#125;, &#123;‘$addToSet’:&#123;‘array’:10&#125; &#125; );执行后: array中有10所以不会添加$each遍历数组, 和 $push 修改器配合可以插入多个值Model.update(&#123;‘age’:22&#125;, &#123;‘$push’:&#123;‘array’:&#123;‘$each’: [1,2,3,4,5]&#125;&#125; &#125; );执行后: array : [10,1,2,3,4,5]$pop向数组中尾部删除一个元素Model.update(&#123;‘age’:22&#125;, &#123;‘$pop’:&#123;‘array’:1&#125; &#125; );执行后: array : [10,1,2,3,4] tips: 将1改成-1可以删除数组首部元素$pull向数组中删除指定元素Model.update(&#123;‘age’:22&#125;, &#123;‘$pull’:&#123;‘array’:10&#125; &#125; );执行后: array : [1,2,3,4] 匹配到array中的10后将其删除 c. 删除 1234567891011121314 const User = require("./user.js"); function del()&#123; const wherestr = &#123;'username' : 'zhangsan'&#125;; User.remove(wherestr, function(err, res)&#123; if (err) &#123; console.log("Error:" + err); &#125; else &#123; console.log("Res:" + res); &#125; &#125;) &#125;del(); 另外，删除和更新的其他方法，常用方法有： Model.findByIdAndUpdate(id, [update], [options], [callback]) // 找到指定id记录并更新 Model.findOneAndUpdate([conditions], [update], [options], [callback]) // 找到一条记录并更新* Model.findByIdAndRemove(id, [options], [callback]) // 找到指定id记录并删除 Model.findOneAndRemove(conditions, [options], [callback]) // 找到一条记录并删除 1234567891011121314const User = require("./user.js");function findByIdAndUpdate()&#123; const id = '56f2558b2dd74855a345edb2'; cibst updatestr = &#123;'userpwd': 'abcd'&#125;; User.findByIdAndUpdate(id, updatestr, function(err, res)&#123; if (err) &#123; console.log("Error:" + err); &#125; else &#123; console.log("Res:" + res); &#125; &#125;)&#125;findByIdAndUpdate(); d. 查询 查询有直接查询和链式查询，链式查询只有在执行exec方法时才执行查询，而且必须有回调 条件查询Model.find(conditions, [fields], [options], [callback])//fields和options是可选参数， field的值中,1为包括，0为不包括，options： 选项参数//fields: 参数用于字段映射，默认情况下，MongoDB会返回匹配文档的所有字段，使用映射(projection）设置希望返回的字段，用于取文档字段的子集，相当于SQL中SELECT后面我们需要的字段 User.find({‘username’ : ‘zhangsn’}, {“username”: 1 ,”_id”: 0}, callback); // 输出只会有username字段，设置方法如上，1表示查询输出该字段，0表示不输出 User.find({userage: {$gte: 21, $lte: 65}}, callback); // 这表示查询年龄大于等21而且小于等于65岁 参数还有： $or 或关系 $nor 或关系取反 $gt 大于 $gte 大于等于 $lt 小于 $lte 小于等于 $ne 不等于 $in 在多个值范围内 $nin 不在多个值范围内 $all 匹配数组中多个值 $regex 正则，用于模糊查询 $size 匹配数组大小 $maxDistance 范围查询，距离（基于LBS） $mod 取模运算 $near 邻域查询，查询附近的位置（基于LBS） $exists 字段是否存在 $elemMatch 匹配内数组内的元素 $within 范围查询（基于LBS） $box 范围查询，矩形范围（基于LBS） $center 范围醒询，圆形范围（基于LBS） $centerSphere 范围查询，球形范围（基于LBS） $slice 查询字段集合中的元素（比如从第几个之后，第N到第M个元素 User.find({‘username’:{$regex:/m/i}}, [callback]) // 模糊查询,正则匹配有’m’的名字，且不区分大小写 数量查询Model.count(conditions, [callback]) // res结果会输出数量，也可以传入条件做条件查询。 根据id查询Model.findById(id, [fields], [options], [callback]) // 要据ID得到数据 分页查询 123456789101112131415161718const User = require("./user.js");function getByPager()&#123; const pageSize = 5; //一页多少条 const currentPage = 1; //当前第几页 const sort = &#123;'logindate':-1&#125;; //排序（按登录时间倒序） const condition = &#123;&#125;; //条件 const skipnum = (currentPage - 1) * pageSize; //跳过数 User.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(function (err, res) &#123; if (err) &#123; console.log("Error:" + err); &#125; else &#123; console.log("Res:" + res); &#125; &#125;)&#125;getByPager(); e. aggregate在MongoDB中，聚合(aggregate)主要用于进行处理数据，比如统计求和，求平均数等，并返回计算后的数据结果，这给我们带来了很多便捷之处，因为可以在读取数据的同时进行数据处理例如： 12345// $match用于获取年龄大于20小于或等于40记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。User.aggregate([ &#123; $match : &#123; userage : &#123; $gt : 20, $lte : 40 &#125; &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125; ]); 下面列举一些： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 更多参数可以参考下方参考链接。 8. 其他注意： 表”应该描述为“collection(集合)”；“行”应该描述为“文档（document）”,一个database中可以有多个collection，一个collection中又可以有多个document 用CMD中使用mongo.exe操作时，插入中文遇一了问题，原因是MongoDB默认编辑是utf-8，而CMD是GBK，所以在CMD窗口中执行这个命令修改编辑即可：chcp 65001 注意mongodb严格区分大小写，比如查询 db.tb2.find({“name”:”wilson0”})和 db.tb2.find({“Name”:”wilson0”}) 并不是用的同一字段做的条件； 参考：mongodb: https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/mongodb查询参数： https://mongodb-documentation.readthedocs.io/en/latest/reference/operator/gt.htmlmongoose: http://mongoosejs.com/docs/api.html#Aggregateblog:http://www.cnblogs.com/zhongweiv/p/node_mongodb.htmlhttps://cnodejs.org/topic/504b4924e2b84515770103dd]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>mongoose</tag>
        <tag>mongodb</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十商]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%8D%81%E5%95%86%2F</url>
    <content type="text"><![CDATA[转载自： https://baike.baidu.com/item/%E5%8D%81%E5%95%86 1. 智商(IQ) 智商(Intelligence Quotient，缩写成IQ)是一种表示人的智力高低的数量指标，但也可以表现为一个人对知识的掌握程度，反映人的观察力、记忆力、思维力、想像力、创造力以及分析问题和解决问题的能力。确实，智商不是固定不变的，通过学习和训练是可以开发增长的。我们要走向成功，就必须不断学习，积累智商。 我们不仅要从书本、从社会学习，还要从我们的上司那里学习。因为你的上司今天能有资格当你的上司，肯定有比你厉害的地方，有很多地方值得你去学习。很多人都想超越他的上司，这是非常可贵的精神，但要超越你的老板，你不学习他成功的地方，何谈超越?不断地学习，提高智商，这是成功的基本条件。 2. 情商(EQ) 情商(Emotional Intelligence Quotient，简写成EQ)，就是管理自己的情绪和处理人际关系的能力。如今，人们面对的是快节奏的生活，高负荷的工作和复杂的人际关系，没有较高的EQ是难以获得成功的。EQ高的人，人们都喜欢同他交往，总是能得到众多人的拥护和支持。同时，人际关系也是人生重要资源，良好的人际关系往往能获得更多的成功机会。权变理论代表人物之一弗雷德&S226;卢森斯(Fred Luthans)对成功的管理者(晋升速度快)与有效的管理者(管理绩效高)做过调查，发现两者显著不同之处在于：维护人际网络关系对成功的管理者贡献最大，占48%，而对有效的管理者只占11%。可见，在职场中，要获得较快的成长，仅仅埋头工作是不够的，良好的人际关系是获得成功的重要因素。 3. 逆商(AQ) 逆商(Adversity Intelligence Quotient，简写成AQ)，是指面对逆境承受压力的能力，或承受失败和挫折的能力。当今和平年代，应付逆境的能力更能使你立于不败之地。“苦难对于天才是一块垫脚石，对于能干的人是一笔财富，而对于弱者则是一个万丈深渊。”“苦难是人生最好的教育。”名人之谈告诉我们：伟大的人格只有经历熔炼和磨难，潜力才会激发，视野才会开阔，灵魂才会升华，才会走向成功，正所谓吃得苦中苦，方为人上人。 任何国家和地区的富豪，约八成出身贫寒或学历较低，他们白手起家创大业，赢得了令人羡慕的财富和名誉。他们没有一个是一帆风顺，甚至大起大落，几经沉浮，不经失败和挫折就获得成功的。 逆境不会长久，强者必然胜利。因为人有着惊人的潜力，只要立志发挥它，就一定能渡过难关，成就生命的辉煌。 4. 德商(MQ) 德商(Moral Intelligence Quotient，缩写成MQ)，是指一个人的德性水平或道德人格品质。德商的内容包括体贴、尊重、容忍、宽恕、诚实、负责、平和、忠心、礼貌、幽默等各种美德。我们常说的“德智体”中是把德放在首位的;科尔斯说，品格胜于知识。可见，德是最重要的。一个有高德商的人，一定会受到信任和尊敬，自然会有更多成功的机会。 古人云：“得道多助，失道寡助”、“道之以德，德者得也”，就是告诉我们要以道德来规范自己的行为，不断修炼自己，才能获得人生的成功。古今中外，一切真正的成功者，在道德上大都达到了很高的水平。 现实中的大量事实说明，很多人的失败，不是能力的失败，而是做人的失败、道德的失败。 5. 胆商(DQ) 胆商(Daring Intelligence Quotient，缩写成DQ)是一个人胆量、胆识、胆略的度量，体现了一种冒险精神。胆商高的人能够把握机会，该出手时就出手。无论是什么时代，没有敢于承担风险的胆略，任何时候都成不了气候。而大凡成功的商人、政客，都是具有非凡胆略和魄力的。 6. 财商(FQ) 财商(Financial Intelligence Quotient，简写成FQ)，是指理财能力，特别是投资收益能力。没有理财的本领，你有多少钱也会慢慢花光的，所谓“富不过三代”就是指有财商的老子辛辛苦苦积攒下来的钱，最多最后也会败在无财商的子孙手中。财商是一个人最需要的能力，也是最被人们忽略的能力。 我们的父辈都是“穷爸爸”，只教我们好好读书，找好工作，多存钱，少花钱。赚得少一点没关系，关键是稳定。他们从没教过我要有财商，要考虑怎么理财。所以，财商对我们来说是迫切需要培养的一种能力。会理财的人越来越富有，一个关键的原因就是财商区别。特别是富人，何以能在一生中积累如此巨大的财富?答案是：投资理财的能力。 7. 心商(MQ) 心商(Mental Intelligence Quotient，简写成MQ)，就是维持心理健康，调试心理压力，保持良好心理状况和活力的能力。21世纪是“抑郁时代”，人类面临更大的心理压力，提高心商，保持心理健康已成为时代的迫切需要。现代人渴望成功，而成功越来越取决于一个人的心理状态，取决于一个人的心理健康。从某种意义上来讲，心商的高低，直接决定了人生过程的苦乐，主宰人生命运的成败。 世上有很多人，取得了很大的成功，可因承受着生活的各种压力，郁郁寡欢，因不堪重压或经不起生命的一次挫折患上心理障碍，甚至走上不归路，演绎一幕幕人间悲剧。 8. 志商(WQ) “志商”就是意志智商(Will Intelligence Quotient，简写成WQ )，指一个人的意志品质水平，包括坚韧性、目的性、果断性、自制力等方面。如能为学习和工作具有不怕苦和累的顽强拼搏精神，就是高志商。 “志不强者智不达，言不信者行不果”、“勤能补拙是良训，一分辛劳一分才”。它们说明一个道理：志商对一个人的智慧具有重要的影响。人生是小志小成，大志大成。许多人一生平淡，不是因为没有才干，而是缺乏志向和清晰的发展目标。在商界尤其如此，要成就出色的事业，就得要有远大的志向。 9. 灵商(SQ) 灵商(Spiritual Intelligence Quotient，简写成SQ)，就是对事物本质的灵感、顿悟能力和直觉思维能力。量子力学之父普朗克认为，富有创造性的科学家必须具有鲜明的直觉想像力。无论是阿基米德从洗澡中获得灵感最终发现了浮力定律，牛顿从掉下的苹果中得到启发发现了万有引力定律，还是凯库勒关于蛇首尾相连的梦而导致苯环结构的发现，都是科学史上灵商飞跃的不朽例证。 成功人生没有定式，单靠成文的理论是解决不了实际问题的，还得需要悟性，需要灵商的闪现。修炼灵商，关键在于不断学习、观察、思考，要敢于大胆的假设，敢于突破传统思维。 10.健商(HQ) 健商(Health Intelligence Quotient，简写成HQ)是指个人所具有的健康意识、健康知识和健康能力的反映。健康是人生最大的财富，就好象健康是1，事业、爱情、金钱、家庭、友谊、权力等等是1后面的零，所以光有1的人生是远远不够的，但是失去了1(健康)，后面的0再多对你也没有任何意义，正所谓平安是福。所以幸福的前提是关爱、珍惜自己的生命，并努力地去创造、分享事业、爱情、财富、权力等等人生价值。 此外还有CQ、LQ、SQ 的概念。 类似灵商(SQ)的概念，还有CQ：CQ 也就是Creation Quotient，“创造力智商”是一个全新的名词构建。“创造力”永远是一股青春的活力，它能使人永葆青春，即使人到暮年，仍是老骥枥、壮心不已。创造，就不怕时光的逝去，不怕人生在世短短几个秋，因为有创造、就不怕死亡。CQ ，还表示 Charisma Quotient ，愈有CQ 个性魅力，愈有成功机率。所谓个性，就是要反对机械化、模式化，在当代社会，科技发达，保持个人的个性，是相当不易的，有个性才有存在的必要，特别是人，没有了个性那是一件相当可怕的事。现在电扭一按、或是遥控器一动，马上就可以进入电视这个“地球村”，久而久之，人的一动就处处一致了，用的是电视语言、做的是电视动作，何“个性魅力”之有？食物、用品可以大规模统一化，而人一旦失去了个性全如一个模子里倒出来似的：才能、本能、知识、追求……一切的一切，全部一样，那就会形成千军万马过独木桥、而有的阳光大道上却无一人行走的局面了。所以提倡CQ个性魅力。提倡人们在穿着打扮、谈吐、仪态、思想等方面，不要附庸潮流、附庸他人，要有自己的个性魅力。 LQ：LQ（Love Quotient）爱的智商，能使人和人相亲相爱，对大自然、创作、哲学、运动、学习……等各种角色、各种职业人的扮演，都能抱着热情和执著的一种能力。具有这种能力的人，即使IQ 差一点，EQ 不够好，一样能在专业的领域占有一席之地，甚至挣出自己的一片天。爱的智商无比重要，因为爱是伟大的，如果一个人失去了爱心，就说明他（她）的心已经死了，成了名副其实的“诛心人”，没有爱的人，怎么能够勇敢地承受一切？怎么能够无畏地活下去？——微笑，深呼吸，慢行，步子要稳……这就是爱，这就是爱情的智力商数。 SQ：SQ（Smile Quotient）“笑商”，善意的微笑，是人际的润滑剂，使陌生人、亲近的人都有一种宾至如归、春风化雨般的亲切感。经常乐观大笑，更使人易于亲近。“老顽童”在人们的印象中总比“少无常”好玩得多。笑，尤其是微笑、开心一笑，都是友善的。这样的人，当然比经常带着一张苦瓜脸的人容易出头或成功。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建发布自己的npm包]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAnpm%E5%8C%85%2F</url>
    <content type="text"><![CDATA[开始做之前确认node.js是已安装的。 NPM包构建 创建demo目录，新建index.js文件index.js文件示例： module.exports.sayHello = function(){ return &quot;Hello World!&quot;; } 在项目中引导创建一个package.json文件 npm init 注册npm账号 要发布npm包当然需要在npm官网注册一个属于自己的账号npm官网地址： https://www.npmjs.com或者通过命令创建： npm addUser 在cmd中登录账号注册成功后，打开cmd进入到demo目录，登录账号： npm login 输入用户密码以及邮箱，登录成功后可以输入查询命令： npm whoami 就能看到你酷酷的账号名了~~ 上传npm包 cmd进到demo目录，输入如下命令： npm publish 这时候npm可能会报错，不要紧张： npm ERR! publish Failed PUT 403 npm ERR! code E403 npm ERR! you do not have permission to publish &quot;demo&quot;. Are you logged in as the correct user? : demo 这是什么原因？？就是与npm仓库的包名重复了拿出package.json文件，把name字段值改成下面： &quot;name&quot;: &quot;test-demo-one&quot; 还有一点要注意的是npm对包名的限制：不能有大写字母/空格/下滑线 npm包管理 管理npm包权限 查看模块拥有者 $ npm owner ls &lt;package_name&gt; 添加发布者 $ npm owner add &lt;user&gt; &lt;package_name&gt; 删除发布者 $ npm owner rm &lt;user&gt; &lt;package_name&gt; 撤销发布包( 在项目目录下执行 ) npm unpublish --force 主要是处于安全性考虑，在Azer NPM 撤包事件后，npm公布了一版新的规则，如下： 版本更新少于24小时的包允许下架； 超过24小时的包的下架需要联系npm维护者； 如果有npm维护者参与，npm将检查是否有其他包依赖该包，如果有则不允下架； 如果某个包的所有版本都被移除，npm会上传一个空的占位包，以防后来的使用者不小心引用怀有恶意的替代者。 npm的版本控制npm version patch npm version minor npm version major 例如：我原本的项目是1.0.0版本的话 若是1中情况，变为1.0.1 若是2中情况，变为1.1.0 若是3中情况，变为2.0.0 不过也可以在package.json中的version更改~~ 使用npm包在要使用的项目中： npm install --save-dev test-demo-one 即可； 扩展： 好的npm包，要有完整的md描述，以及测试用例，可以参考下：https://github.com/parro-it/awesome-micro-npm-packages这里有一些简单的npm包，可以参考学习下；]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5锁屏倒计时失效问题]]></title>
    <url>%2F2018%2F04%2F08%2Fh5%E9%94%81%E5%B1%8F%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[最近开发微信内嵌h5页面时遇到一个问题，ios手机锁屏倒计时没有走，翻阅了一些资料，解决了这个问题： 刚开始代码是： let seconds = 120; this.time = setInterval(() =&gt; { seconds --; this.verificationContent = &apos;倒计时&apos; + seconds + &apos;s&apos;; if (seconds === 0) { clearInterval(this.time); this.time = 0; } }) 后来我添加了meta标签： 可以在meta里进行设置，设置页面nocache，每次访问次页面，均需要从服务器重新获取，而不是使用缓存中读取 expires设定过期时间，一旦过期就必须请求服务器， expries出现在http-equiv属性中，使用content属性表示页面缓存的过期时间 expries=0，缓存过期前的分钟数。若用户在页面过期前返回该页面，就会显示缓存的版本页 &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 但是仍然没有起作用，后来用获取系统时间做差值，解决了这个问题： let nowTime = (new Date).getTime(); this.time = setInterval(() =&gt; { let currTime = (new Date).getTime(); let seconds = 120 - Math.floor((currTime - nowTime)/1000); this.verificationContent = &apos;倒计时&apos; + seconds + &apos;s&apos;; if (seconds === 0) { clearInterval(this.time); this.time = 0; } })]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native & node 入门学习]]></title>
    <url>%2F2018%2F04%2F01%2Frn-node%2F</url>
    <content type="text"><![CDATA[react：点击此处 react-native学习思维导图：点击此处 node入门：点击此处]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>node react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现文本选中复制粘贴]]></title>
    <url>%2F2018%2F03%2F25%2Fjs%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%2F</url>
    <content type="text"><![CDATA[用原生js实现文本的复制粘贴，主要使用的到了Ranga(所谓”Range”，是指HTML文档中任意一段内容)来实现复制，用document.execCommand来实现复制粘贴，代码如下： let selection = window.getSelection() let range = document.createRange(); selection.removeAllRanges(); range.selectNode(e.target);（注意和selectNodeContents()的区别，有时用到后面一个） window.getSelection().addRange(range); window.execCommand(&apos;copy&apos;) 参考：windwo.execCommand()介绍Ranga介绍ranga.selectNode()介绍ranga.selectNodeContents()介绍]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react + redux + eslint简单dmeo]]></title>
    <url>%2F2018%2F03%2F19%2Freact-practice%2F</url>
    <content type="text"><![CDATA[搭建简单React工程源码地址： https://github.com/weiyuan0609/react-practice npm init 生成 package.json 文件. 安装依赖包npm install –save react - 安装React.npm install –save react-dom 安装React Dom,这个包是用来处理virtual DOM。用React Native的话，这里就是安装react-native。npm install –save-dev webpack - 安装Webpacknpm install –save-dev webpack-dev-server - webpack官网出的一个小型express服务器，主要特性是支持热加载npm install –save-dev babel-core - 安装Babel,可以把ES6转换为ES5，注意Babel最新的V6版本分为babel-cli和babel-core两个模块，这里只需要用babel-cor即可npm install –save-dev babel-loader - webpack中需要用到的loader.安装babel相关插件npm install –save babel-runtimenpm install –save-dev babel-plugin-transform-runtimenpm install –save-dev babel-preset-es2015npm install –save-dev babel-preset-reactnpm install –save-dev babel-preset-stage-2 打开 package.json 然后添加下面的scripts: &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --hot --inline --colors --content-base&quot;, &quot;build&quot;: &quot;webpack --progress --colors&quot; } 创建webpack配置文件，webpack.config.js来命名这个配置文件，假如你用别的名字比如webpack.config.prod.js那么上面的脚本build就需要相应的改变指定相应的配置文件名字：”build”: “webpack webpack.config.prod.js –progress –colors” var webpack = require(‘webpack’); module.exports = { entry: &apos;./src/app.js&apos;, output: { path: __dirname + &apos;/build&apos;, filename: &quot;bundle.js&quot; }, mode: &apos;development&apos;, // 若是webpack4以上 要添加这个 module: { rules: [{ test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loader&apos;, query: { plugins: [&apos;transform-runtime&apos;], presets: [&apos;es2015&apos;, &apos;react&apos;, &apos;stage-2&apos;] } }, { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; }] } }; 以上基本环境搭建完。 ##创建react组件 首先我们在项目根目录中新建一个 index.html 文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 建立一个新的文件夹 src. 代码都将放在这个文件夹里面。在 src 中建立 app.js，作为React的根组件,其他所有的组件都会注入到这个跟组件中 首先我们需要导入react，现在都已经用ES6的语法， import React from ‘react’; ， 然后我们要引入react-dom. 这里面有react中最重要的一个虚拟dom的概念.引入代码：import ReactDOM from ‘react-dom’; 在 app.js 的下面添加: ReactDOM.render(, document.getElementById(‘app’)); 第一个参数就是我们App的根组件, 写作的形式. 第二个参数就是我们的APP将要主要的DOM元素. 在这个项目中，就是我们在index中写的id为app的 div标签 启动就可以看到 hello world import React from &apos;react&apos; import ReactDOM from &apos;react-dom&apos; class App extends React.Component { render() { return ( &lt;div&gt; Hello World test &lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;)) 创建列表list添加删除功能组件（components） https://github.com/weiyuan0609/react-practice/tree/temp2 添加redux 和 eslint https://github.com/weiyuan0609/react-practice/tree/master 参考文献：react:https://doc.react-china.org/docs/hello-world.html redux:https://redux.js.org/ 其他：http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建总结]]></title>
    <url>%2F2018%2F03%2F10%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[hexo搭建参考：https://hexo.io/zh-cn/ next配置：https://segmentfault.com/a/1190000009544924#articleHeader23http://theme-next.iissnan.com/third-party-services.html#algolia-search 总结：之前用的电脑hexo上传到github,换了电脑后，配置全没了，幸亏之前有配置rss,直接导出了所有文档，所以rss最好配置上，以防万一。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex]]></title>
    <url>%2F2018%2F01%2F19%2FFlex%2F</url>
    <content type="text"><![CDATA[Web的Flex弹性盒模型: 点击此处 学习链接: 语法篇 实例篇]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>flex</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js排序算法小结]]></title>
    <url>%2F2018%2F01%2F17%2Fjs%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[排序算法说明（1）排序的定义：对一序列对象根据某个关键字进行排序； 输入：n个数：a1,a2,a3,…,an输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。 再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。 （3）对于评述算法优劣术语的说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度: 一个算法执行所耗费的时间。空间复杂度: 运行完一个程序所需内存的大小。 关于时间空间复杂度的更多了解请戳这里，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。 （4）排序算法图片总结(图片来源于网络): 排序对比： 图片名词解释：n: 数据规模k:“桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存 排序分类： 冒泡排序（Bubble Sort） 好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。 (1)算法描述 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 (2)算法描述和实现具体算法描述如下： .比较相邻的元素。如果第一个比第二个大，就交换它们两个； .对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； .针对所有的元素重复以上的步骤，除了最后一个； .重复步骤1~3，直到排序完成。 JavaScript代码实现： javascript： function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &amp;lt; len; i++) { for (var j = 0; j &amp;lt; len - 1 - i; j++) { if (arr[j] &amp;gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]`&lt;/pre&gt;&gt; **改进冒泡排序： **设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 改进后算法如下: javascript: &lt;pre&gt;`function bubbleSort2(arr) { console.time(&amp;apos;改进后冒泡排序耗时&amp;apos;); var i = arr.length-1; //初始时,最后位置保持不变 while ( i&amp;gt; 0) { var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&amp;lt; i; j++) if (arr[j]&amp;gt; arr[j+1]) { pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; } i= pos; //为下一趟排序作准备 } console.timeEnd(&amp;apos;改进后冒泡排序耗时&amp;apos;); return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]`&lt;/pre&gt;&gt; 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 改进后的算法实现为: javascript: &lt;pre&gt;`function bubbleSort3(arr3) { var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time(&amp;apos;2.改进后冒泡排序耗时&amp;apos;); while (low &amp;lt; high) { for (j= low; j&amp;lt; high; ++j) //正向冒泡,找到最大者 if (arr[j]&amp;gt; arr[j+1]) { tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; } --high; //修改high值, 前移一位 for (j=high; j&amp;gt;low; --j) //反向冒泡,找到最小者 if (arr[j]&amp;lt;arr[j-1]) { tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; } ++low; //修改low值,后移一位 } console.timeEnd(&amp;apos;2.改进后冒泡排序耗时&amp;apos;); return arr3;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]`&lt;/pre&gt; 三种方法耗时对比： ![这里写图片描述](http://img.blog.csdn.net/20160916163126374) &gt; 由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~ **冒泡排序动图演示:** ![这里写图片描述](http://img.blog.csdn.net/20160916160748389) **(3)算法分析** 最佳情况：T(n) = O(n)&gt; 当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….） 最差情况：T(n) = O(n2)&gt; 当输入的数据是反序时(卧槽，我直接反序不就完了….) 平均情况：T(n) = O(n2) 选择排序（Selection Sort） 表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 (1)算法简介 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 (2)算法描述和实现n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： .初始状态：无序区为R[1..n]，有序区为空； .第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； .n-1趟结束，数组有序化了。 Javascript代码实现: javascript: `function selectionSort(arr) { var len = arr.length; var minIndex, temp; console.time(&apos;选择排序耗时&apos;); for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { //寻找最小的数 minIndex = j; //将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } console.timeEnd(&apos;选择排序耗时&apos;); return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]` 选择排序动图演示： (3)算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 插入排序（Insertion Sort） 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了….. (1)算法简介 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 (2)算法描述和实现一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： .从第一个元素开始，该元素可以认为已经被排序； .取出下一个元素，在已经排序的元素序列中从后向前扫描； .如果该元素（已排序）大于新元素，将该元素移到下一位置； .重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； .将新元素插入到该位置后； .重复步骤2~5。 Javascript代码实现: javascript:function insertionSort(array) { if (Object.prototype.toString.call(array).slice(8, -1) === &amp;apos;Array&amp;apos;) { console.time(&amp;apos;插入排序耗时：&amp;apos;); for (var i = 1; i &amp;lt; array.length; i++) { var key = array[i]; var j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; array[j] &amp;gt; key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } console.timeEnd(&amp;apos;插入排序耗时：&amp;apos;); return array; } else { return &amp;apos;array is not an Array!&amp;apos;; }}&gt; 改进插入排序： 查找插入位置时使用二分查找的方式 javascript:function binaryInsertionSort(array) { if (Object.prototype.toString.call(array).slice(8, -1) === &amp;apos;Array&amp;apos;) { console.time(&amp;apos;二分插入排序耗时：&amp;apos;); for (var i = 1; i &amp;lt; array.length; i++) { var key = array[i], left = 0, right = i - 1; while (left &amp;lt;= right) { var middle = parseInt((left + right) / 2); if (key &amp;lt; array[middle]) { right = middle - 1; } else { left = middle + 1; } } for (var j = i - 1; j &amp;gt;= left; j--) { array[j + 1] = array[j]; } array[left] = key; } console.timeEnd(&amp;apos;二分插入排序耗时：&amp;apos;); return array; } else { return &amp;apos;array is not an Array!&amp;apos;; }}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]&gt; 改进前后对比： 插入排序动图演示: (3)算法分析 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n2) 平均情况：T(n) = O(n2) 希尔排序（Shell Sort） 1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 (1)算法简介 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。 (2)算法描述和实现先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： . 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； .按增量序列个数k，对序列进行k 趟排序； .每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Javascript代码实现： javascript: `function shellSort(arr) { var len = arr.length, temp, gap = 1; console.time(&apos;希尔排序耗时:&apos;); while(gap &lt; len/5) { //动态定义间隔序列 gap =gap*5+1; } for (gap; gap &gt; 0; gap = Math.floor(gap/5)) { for (var i = gap; i &lt; len; i++) { temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } console.timeEnd(&apos;希尔排序耗时:&apos;); return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]` 希尔排序图示（图片来源网络）： （3）算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog n) 归并排序（Merge Sort） 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 (1)算法简介 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 (2)算法描述和实现具体算法描述如下： .把长度为n的输入序列分成两个长度为n/2的子序列； .对这两个子序列分别采用归并排序； .将两个排序好的子序列合并成一个最终的排序序列。 Javscript代码实现: javascript `function mergeSort(arr) { //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));}function merge(left, right){ var result = []; console.time(&apos;归并排序耗时&apos;); while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd(&apos;归并排序耗时&apos;); return result;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr));` 归并排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 快速排序（Quick Sort） 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。 (1)算法简介 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 (2)算法描述和实现快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 Javascript代码实现： javascript/*方法说明：快速排序@param array 待排序数组*///方法一function quickSort(array, left, right) { console.time(&amp;apos;1.快速排序耗时&amp;apos;); if (Object.prototype.toString.call(array).slice(8, -1) === &amp;apos;Array&amp;apos; &amp;amp;&amp;amp; typeof left === &amp;apos;number&amp;apos; &amp;amp;&amp;amp; typeof right === &amp;apos;number&amp;apos;) { if (left &amp;lt; right) { var x = array[right], i = left - 1, temp; for (var j = left; j &amp;lt;= right; j++) { if (array[j] &amp;lt;= x) { i++; temp = array[i]; array[i] = array[j]; array[j] = temp; } } quickSort(array, left, i - 1); quickSort(array, i + 1, right); } console.timeEnd(&amp;apos;1.快速排序耗时&amp;apos;); return array; } else { return &amp;apos;array is not an Array or left or right is not a number!&amp;apos;; }}//方法二var quickSort2 = function(arr) { console.time(&amp;apos;2.快速排序耗时&amp;apos;); if (arr.length &amp;lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &amp;lt; arr.length; i++){ if (arr[i] &amp;lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } }console.timeEnd(&amp;apos;2.快速排序耗时&amp;apos;); return quickSort2(left).concat([pivot], quickSort2(right));};var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 快速排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 堆排序（Heap Sort） 堆排序可以说是一种利用堆的概念来排序的选择排序。 (1)算法简介 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 (2)算法描述和实现具体算法描述如下： .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 Javascript代码实现： javascript /_方法说明：堆排序 @param array 待排序数组_/ function heapSort(array) { console.time(‘堆排序耗时’); if (Object.prototype.toString.call(array).slice(8, -1) === ‘Array’) { //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &amp;gt;= 0; i–) { heapify(array, i, heapSize); } ` //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) { temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); } console.timeEnd(&apos;堆排序耗时&apos;); return array; } else { return &apos;array is not an Array!&apos;; }}/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) { if (Object.prototype.toString.call(arr).slice(8, -1) === &apos;Array&apos; &amp;&amp; typeof x === &apos;number&apos;) { var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) { largest = l; } if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) { largest = r; } if (largest != x) { temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); } } else { return &apos;arr is not an Array or x is not a number!&apos;; }}var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]` 堆排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 (1)算法简介 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 (2)算法描述和实现具体算法描述如下： . 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 Javascript代码实现： javascript `function countingSort(array) { var len = array.length, B = [], C = [], min = max = array[0]; console.time(&apos;计数排序耗时&apos;); for (var i = 0; i &lt; len; i++) { min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; } for (var j = min; j &lt; max; j++) { C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); } for (var k = len - 1; k &gt;= 0; k--) { B[C[array[k]] - 1] = array[k]; C[array[k]]--; } console.timeEnd(&apos;计数排序耗时&apos;); return B;}var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]` JavaScript动图演示：、 (3)算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 (1)算法简介 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 (2)算法描述和实现具体算法描述如下： .设置一个定量的数组当作空桶； .遍历输入数据，并且把数据一个一个放到对应的桶里去； .对每个不是空的桶进行排序； .从不是空的桶里把排好序的数据拼接起来。 Javascript代码实现: javascript/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) { if (array.length &amp;lt;= 1) { return array; } var len = array.length, buckets = [], result = [], min = max = array[0], regex = &amp;apos;/^[1-9]+[0-9]*$/&amp;apos;, space, n = 0; num = num || ((num &amp;gt; 1 &amp;amp;&amp;amp; regex.test(num)) ? num : 10); console.time(&amp;apos;桶排序耗时&amp;apos;); for (var i = 1; i &amp;lt; len; i++) { min = min &amp;lt;= array[i] ? min : array[i]; max = max &amp;gt;= array[i] ? max : array[i]; } space = (max - min + 1) / num; for (var j = 0; j &amp;lt; len; j++) { var index = Math.floor((array[j] - min) / space); if (buckets[index]) { // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &amp;gt;= 0 &amp;amp;&amp;amp; buckets[index][k] &amp;gt; array[j]) { buckets[index][k + 1] = buckets[index][k]; k--; } buckets[index][k + 1] = array[j]; } else { //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); } } while (n &amp;lt; num) { result = result.concat(buckets[n]); n++; } console.timeEnd(&amp;apos;桶排序耗时&amp;apos;); return result;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 桶排序图示（图片来源网络）： 关于桶排序更多 (3)算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； (1)算法简介 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 (2)算法描述和实现具体算法描述如下： .取得数组中的最大数，并取得位数； .arr为原始数组，从最低位开始取每个位组成radix数组； .对radix进行计数排序（利用计数排序适用于小范围数的特点）； Javascript代码实现： javascript`/* 基数排序适用于： (1)数据范围较小，建议在小于1000 (2)每个数值都要大于等于0 @author xiazdong @param arr 待排序数组 @param maxDigit 最大位数 ///LSD Radix Sortfunction radixSort(arr, maxDigit) { var mod = 10; var dev = 1; var counter = []; console.time(&apos;基数排序耗时&apos;); for (var i = 0; i &lt; maxDigit; i++, dev = 10, mod = 10) { for(var j = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]== null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } var pos = 0; for(var j = 0; j &lt; counter.length; j++) { var value = null; if(counter[j]!=null) { while ((value = counter[j].shift()) != null) { arr[pos++] = value; } } } } console.timeEnd(&apos;基数排序耗时&apos;); return arr;}var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 基数排序LSD动图演示： (3)算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 本文代码链接：https://github.com/weiyuan0609/arithmetic-demo]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts -- 柱状堆叠图实例]]></title>
    <url>%2F2017%2F12%2F25%2Fecharts-%E6%9F%B1%E7%8A%B6%E5%A0%86%E5%8F%A0%E5%9B%BE%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[echarts – 柱状堆叠图实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图三 -- 柱状堆叠图&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/3.7.1/echarts.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 750px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script&gt; var myChart = echarts.init(document.getElementById(&apos;main&apos;)); var option = { title: { text: &apos;供应商&apos;, x: &apos;center&apos; }, tooltip: { trigger: &apos;axis&apos;, // hover 触发事件 axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : &apos;shadow&apos; // 默认为直线，可选为：&apos;line&apos; | &apos;shadow&apos; } }, grid: { right: &apos;150&apos;, // 图组件距离右边距离 }, legend: { data: [&apos;新增审核中供应商数&apos;, &apos;新增认证供应商数&apos;, &apos;上月供应商累计总数&apos;], top: &apos;20%&apos;, right: &apos;0&apos;, width: 150, // selectedMode:false // 取消图例的点击事件 }, xAxis: { type: &apos;category&apos;, data: [&apos;JAN&apos;,&apos;FEB&apos;,&apos;MAR&apos;,&apos;APR&apos;,&apos;MAY&apos;,&apos;JUN&apos;,&apos;JUL&apos;,&apos;AUG&apos;,&apos;SEP&apos;,&apos;OCT&apos;,&apos;NOV&apos;,&apos;DEC&apos;] }, yAxis: { type: &apos;value&apos;, splitLine:{show: false} // 去掉网格线 }, series: [ { name:&apos;新增审核中供应商数&apos;, type:&apos;bar&apos;, barWidth: &apos;50%&apos;, // 柱状宽度 stack: &apos;供应商&apos;, // 堆积 data:[120, 132, 101, 134, 90, 230, 210, 22, 22, 44, 44, 66] }, { name:&apos;新增认证供应商数&apos;, type:&apos;bar&apos;, stack: &apos;供应商&apos;, // 堆积 data:[120, 132, 101, 134, 90, 230, 210, 22, 33, 33, 34, 66] }, { name:&apos;上月供应商累计总数&apos;, type:&apos;bar&apos;, stack: &apos;供应商&apos;, // 堆积 data:[120, 132, 101, 134, 90, 230, 210, 22, 44, 44, 0, 55], itemStyle : { // 柱状颜色 normal : { color: &apos;blue&apos; } } }, ] }; myChart.setOption(option); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts -- 饼图实例]]></title>
    <url>%2F2017%2F12%2F25%2Fecharts-%E9%A5%BC%E5%9B%BE%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[echarts – 饼图实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图五 -- 饼状图&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/3.7.1/echarts.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 237px;height:237px;&quot;&gt;&lt;/div&gt; &lt;script&gt; var myChart = echarts.init(document.getElementById(&apos;main&apos;)); var option = { title: { text: &apos;{a|0.00%}&apos;, subtext: &apos;{b|有效匹配}&apos;, show:true, x: &apos;center&apos;, y: &apos;90&apos;, textStyle: { color: &apos;#D0021B&apos;, rich: { a: { color: &apos;#D0021B&apos;, fontWeight: &apos;bold&apos;, fontSize: 12, backgroundColor: &apos;#FDEBEB&apos;, borderRadius: 12, padding: [5, 12] } } }, subtextStyle: { rich: { b: { color: &apos;#999&apos;, fontSize: 12, lineHeight: 5 } } } }, color:[&apos;#8AC34C&apos;, &apos;#D68A8A&apos;], tooltip: { trigger: &apos;item&apos;, formatter: &quot;{a} &lt;br/&gt;{b}: {c} ({d}%)&quot; }, series: [ { data: [ {value: 30, name:&apos;有效匹配&apos;}, {value: 20, name:&apos;无效匹配&apos;} ], name:&apos;&apos;, type:&apos;pie&apos;, radius: [&apos;50%&apos;, &apos;70%&apos;], avoidLabelOverlap: false, hoverOffset: 5, label: { normal: { show: false, }, emphasis: { show: false } }, labelLine: { normal: { show: false } }, itemStyle: { //itemStyle有正常显示：normal，有鼠标hover的高亮显示：emphasis emphasis:{//normal显示阴影,与shadow有关的都是阴影的设置 shadowBlur: 3,//阴影大小 shadowOffsetX:0,//阴影水平方向上的偏移 shadowColor:&apos;rgba(0,0,0,0.5)&apos;//阴影颜色 } } } ] }; myChart.setOption(option); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts -- 混合图实例]]></title>
    <url>%2F2017%2F12%2F25%2Fecharts-%E6%B7%B7%E5%90%88%E5%9B%BE%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[echarts – 混合图实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图四 -- 混合图&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/3.7.1/echarts.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 750px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script&gt; var myChart = echarts.init(document.getElementById(&apos;main&apos;)); var option = { title: { text: &apos;供应商&apos;, x: &apos;center&apos; }, tooltip: { trigger: &apos;axis&apos;, // hover 触发事件 axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : &apos;shadow&apos; // 默认为直线，可选为：&apos;line&apos; | &apos;shadow&apos; } }, grid: { right: &apos;150&apos;, // 图组件距离右边距离 }, legend: { data: [&apos;新增审核中供应商数&apos;, &apos;新增认证供应商数&apos;, &apos;上月供应商累计总数&apos;, &apos;当月供应商累计总数&apos;], top: &apos;20%&apos;, right: &apos;0&apos;, width: 150, // selectedMode:false // 取消图例的点击事件 }, xAxis: { type: &apos;category&apos;, data: [&apos;JAN&apos;,&apos;FEB&apos;,&apos;MAR&apos;,&apos;APR&apos;,&apos;MAY&apos;,&apos;JUN&apos;,&apos;JUL&apos;,&apos;AUG&apos;,&apos;SEP&apos;,&apos;OCT&apos;,&apos;NOV&apos;,&apos;DEC&apos;] }, yAxis: { type: &apos;value&apos;, splitLine:{show: false} // 去掉网格线 }, series: [ { name:&apos;新增审核中供应商数&apos;, type:&apos;bar&apos;, barWidth: &apos;50%&apos;, // 柱状宽度 stack: &apos;供应商&apos;, // 堆积 data:[120, 132, 101, 134, 90, 230, 210, 22, 22, 44, 44, 66] }, { name:&apos;新增认证供应商数&apos;, type:&apos;bar&apos;, stack: &apos;供应商&apos;, // 堆积 data:[120, 132, 101, 134, 90, 230, 210, 22, 33, 33, 34, 66] }, { name:&apos;上月供应商累计总数&apos;, type:&apos;bar&apos;, stack: &apos;供应商&apos;, // 堆积 data:[120, 132, 101, 134, 90, 230, 210, 22, 44, 44, 0, 55], itemStyle : { // 柱状颜色 normal : { color: &apos;blue&apos; } } }, { name:&apos;当月供应商累计总数&apos;, type:&apos;line&apos;, symbol:&apos;none&apos;, // 去掉拐点 itemStyle : { normal : { color: &apos;blue&apos;, lineStyle:{ width:3,//折线宽度 color:&quot;blue&quot;//折线颜色 } } }, data:[360, 666, 555, 444, 777, 555, 444, 333, 555, 666, 555, 666] }, ] }; myChart.setOption(option); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts -- 柱状图实例]]></title>
    <url>%2F2017%2F12%2F25%2Fecharts-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[echarts – 柱状图实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图二 -- 柱状图&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/3.7.1/echarts.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script&gt; var myChart = echarts.init(document.getElementById(&apos;main&apos;)); var option = { title: { text: &apos;询价数量&apos;, x: &apos;center&apos; }, tooltip: {}, legend: { data: [&apos;询价数量&apos;], bottom: &apos;0&apos;, selectedMode:false // 取消图例的点击事件 }, xAxis: { type: &apos;category&apos;, data: [&apos;JAN&apos;,&apos;FEB&apos;,&apos;MAR&apos;,&apos;APR&apos;,&apos;MAY&apos;,&apos;JUN&apos;,&apos;JUL&apos;,&apos;AUG&apos;,&apos;SEP&apos;,&apos;OCT&apos;,&apos;NOV&apos;,&apos;DEC&apos;], /*axisTick: { // x轴坐标点为准 alignWithLabel: true }*/ }, yAxis: { type: &apos;value&apos;, splitLine:{show: false} // 去掉网格线 }, series: [ { name:&apos;询价数量&apos;, type:&apos;bar&apos;, barWidth: &apos;50%&apos;, // 柱状宽度 data:[120, 132, 101, 134, 90, 230, 210, 22], itemStyle : { // 柱状颜色 normal : { color: &apos;blue&apos; } } } ] }; myChart.setOption(option); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts -- 折线图实例]]></title>
    <url>%2F2017%2F12%2F25%2Fecharts-%E6%8A%98%E7%BA%BF%E5%9B%BE%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[echarts – 折线图实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图一 -- 折线图&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/3.7.1/echarts.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script&gt; var myChart = echarts.init(document.getElementById(&apos;main&apos;)); var option = { title: { text: &apos;日均销售额&apos;, x: &apos;center&apos; }, tooltip: {}, legend: { data: [&apos;日均销售额&apos;], bottom: &apos;0&apos;, selectedMode:false // 取消图例的点击事件 }, xAxis: { type: &apos;category&apos;, data: [&apos;JAN&apos;,&apos;FEB&apos;,&apos;MAR&apos;,&apos;APR&apos;,&apos;MAY&apos;,&apos;JUN&apos;,&apos;JUL&apos;,&apos;AUG&apos;,&apos;SEP&apos;,&apos;OCT&apos;,&apos;NOV&apos;,&apos;DEC&apos;] }, yAxis: { type: &apos;value&apos;, splitLine:{show: false} // 去掉网格线 }, series: [ { name:&apos;日均销售额&apos;, type:&apos;line&apos;, data:[120, 132, 101, 134, 90, 230, 210, 22], symbol:&apos;circle&apos;, // 拐点样式 symbolSize: 6, // 拐点大小 itemStyle : { normal : { color: &apos;blue&apos;, lineStyle:{ width:3,//折线宽度 color:&quot;blue&quot;//折线颜色 } } }, } ] }; myChart.setOption(option); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts highchart & d3 学习]]></title>
    <url>%2F2017%2F12%2F22%2Fecharts-highchart-d3-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[chart 学习总结最近项目中要制作图表，所以研究了下几个库，总的来说，所有的第三方库都是基于这两种浏览器图形渲染技术实现的： Canvas 和 SVG ，echarts使用的是canvas,而hiaghcharts和d3生成的是svg。highcharts商业使用需要授权。 1.d3.js兼容到ie9，如果企业需要灵活的定制化图表设计，建议使用d3,另外两个只是做了一些基础图表的设计， 官网：https://github.com/d3/d3 学习链接： http://www.ourd3js.com/wordpress/2209/ http://blockbuilder.org/search#text%3Dbar book: 链接:https://pan.baidu.com/s/1cpsDBo 密码:kfit 2.echarts.jsECharts是一个免费的，功能强大的图表和可视化库，为您的商业产品提供了一种简单的方法，即添加直观，交互式和高度可定制的图表。它是用纯JavaScript编写的，基于zrender，这是一个全新的轻量级画布库,如果熟悉canvas,可以看看百度zrender,进行一定的定制开发也是可以的。兼容到ie8. echarts的使用相对简单，只需要按照api,写js,传相关的配置参数即可，渲染出来，例如： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- jquery cdn引入 --&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- echarts 引入 --&gt; &lt;script src=&quot;echarts.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot; style=&quot;width:500px;height:500px;&quot;&gt;&lt;/div&gt; &lt;script&gt; var myChart=echarts.init(document.getElementById(&apos;main&apos;)); //init初始化接口，返回ECharts实例，其中dom为图表所在节点 var option = { //标题 title : { show:true,//显示策略，默认值true,可选为：true（显示） | false（隐藏） text: &apos;主标题&apos;,//主标题文本，&apos;\n&apos;指定换行 link:&apos;&apos;,//主标题文本超链接,默认值true target: null,//指定窗口打开主标题超链接，支持&apos;self&apos; | &apos;blank&apos;，不指定等同为&apos;blank&apos;（新窗口） subtext: &apos;副标题&apos;,//副标题文本，&apos;\n&apos;指定换行 sublink: &apos;&apos;,//副标题文本超链接 subtarget: null,//指定窗口打开副标题超链接，支持&apos;self&apos; | &apos;blank&apos;，不指定等同为&apos;blank&apos;（新窗口） x:&apos;center&apos;//水平安放位置，默认为&apos;left&apos;，可选为：&apos;center&apos; | &apos;left&apos; | &apos;right&apos; | {number}（x坐标，单位px） y: &apos;top&apos;,//垂直安放位置，默认为top，可选为：&apos;top&apos; | &apos;bottom&apos; | &apos;center&apos; | {number}（y坐标，单位px） textAlign: null,//水平对齐方式，默认根据x设置自动调整，可选为： left&apos; | &apos;right&apos; | &apos;center backgroundColor: &apos;rgba(0,0,0,0)&apos;,//标题背景颜色，默认&apos;rgba(0,0,0,0)&apos;透明 borderColor: &apos;#ccc&apos;,//标题边框颜色,默认&apos;#ccc&apos; borderWidth: 0,//标题边框线宽，单位px，默认为0（无边框） padding: 5,//标题内边距，单位px，默认各方向内边距为5，接受数组分别设定上右下左边距 itemGap: 10,//主副标题纵向间隔，单位px，默认为10 textStyle: {//主标题文本样式{&quot;fontSize&quot;: 18,&quot;fontWeight&quot;: &quot;bolder&quot;,&quot;color&quot;: &quot;#333&quot;} fontFamily: &apos;Arial, Verdana, sans...&apos;, fontSize: 12, fontStyle: &apos;normal&apos;, fontWeight: &apos;normal&apos;, }, subtextStyle: {//副标题文本样式{&quot;color&quot;: &quot;#aaa&quot;} fontFamily: &apos;Arial, Verdana, sans...&apos;, fontSize: 12, fontStyle: &apos;normal&apos;, fontWeight: &apos;normal&apos;, }, zlevel: 0,//一级层叠控制。默认0,每一个不同的zlevel将产生一个独立的canvas，相同zlevel的组件或图标将在同一个canvas上渲染。zlevel越高越靠顶层，canvas对象增多会消耗更多的内存和性能，并不建议设置过多的zlevel，大部分情况可以通过二级层叠控制z实现层叠控制。 z: 6,//二级层叠控制，默认6,同一个canvas（相同zlevel）上z越高约靠顶层。 }, //提示框，鼠标悬浮交互时的信息提示 tooltip : { trigger: &apos;item&apos;, formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot; }, //图例，每个图表最多仅有一个图例 legend: { orient: &apos;vertical&apos;, left: &apos;left&apos;, data: [&apos;第一部分&apos;,&apos;第二部分&apos;,&apos;第三部分&apos;,&apos;第四部分&apos;] }, // 系列列表,每个系列通过 type 决定自己的图表类型 series : [ { name: &apos;访问&apos;, type: &apos;pie&apos;, radius : &apos;62%&apos;, center: [&apos;50%&apos;, &apos;65%&apos;],/ minAngle:&apos;15&apos;, data:[ {name:&quot;第一部分&quot;,value:4}, {name:&quot;第二部分&quot;,value:7}, {name:&quot;第三部分&quot;,value:3}, {name:&quot;第四部分&quot;,value:1}, ], itemStyle: { normal:{ label:{ show:true, formatter: &quot;{b} :\n {c} \n ({d}%)&quot;, position:&quot;inner&quot; } } } } ], }; myChart.setOption(option);// 为echarts对象加载数据 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 官网： http://echarts.baidu.com/index.html 3.highchart.js一直都是兼容 IE6+，支持手机端的。 官网：https://www.hcharts.cn/ book: 链接:https://pan.baidu.com/s/1hsOYmjU 密码:xsies 后续待更新。。。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全基础知识]]></title>
    <url>%2F2017%2F11%2F19%2Fweb%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、常见的安全事件1. 钓鱼 Phishing 往往使用诱惑性的标题，比如：账号出问题了，中奖了 仿冒真实知名站点 为了骗取用户账号和资料，如：银行卡，身份证，住址… 2. 网页篡改 Tampering这种技术，主要是黑客入侵后，对网页进行更改，主要是为了炫耀技术，有时是为了政治行为。 下面介绍下搜索引擎的小技巧 关键字* Hacked by 搜索引擎语法 * Intitle:keyword 标题中含有关键词的网页 Intext:keyword 正文中含有关键词的网页 Site:domain 在某个域名和子域名下的网页 3. 暗链 Hidden hyperlinks一种看不见的链接，黑客入侵后，把链接信息植入代码。 据不完全统计，中文互联网网站安全隐患严重，73%的网站被黑的类型为植入暗链，12%植入网马，15%是网页篡改。 因为这个暗链，产业法律风险小，黑客收入比较高，已经成为非常成熟的产业。 小结： 隐藏在网站当中链接，不能为正常用户点击，也就是为了爬虫引擎准备的，提高网站排名 主要是 网游/医疗/博彩/色情 4. Webshell 网页 一种web后门，一个可执行环境 功能强大，一旦植入，可以执行大部分的命令操作，获取服务器的各种权限 存在的形式有很多， 像 asP/php/jsp 通常他会以文件和正常网页混在一起的形式存在，通过浏览器来访问这个后门，已达到控制目标服务器的目的，控制流量又是像正常访问网站的流量混在一起，所以一般的入侵检测系统很难发现 二、 WEB安全主要分成2类： 客户端：XSS CSRF 点击劫持 URL跳转 服务端：SQL注入 命令注入 1. XSS（Cross Site Script） 跨站脚本 危害： 盗取用户信息，钓鱼，制造蠕虫。。等 概念： 黑客通过HTML注入篡改网页，插入了恶意脚本，当用户在浏览网页时，实现控制用户浏览器行为的一种攻击方式。 分类：存储型，反射型，DOM型 存储型 访问网站，触发XSS 关键点： 是XSS脚本内容是存储在数据库中 反射型 访问携带XSS脚本的链接触发XSS 关键点： 直接从url中提取xss脚本内容 DOM型 访问携带XSS脚本的链接触发XSS 关键点： 通过js从url获取脚本内容，并使用例如innerHTML方法，将xss写入DOM中，触发XSS 区别：DOM型XSS是通过前端js,将xss脚本写入DOM中触发，而反射型XSS是通过后端WEB应用程序将XSS脚本执行到响应页面中，浏览器渲染响应页面时，才触发XSS 2. CSRF（Cross-site request forgery） 跨站请求伪造 危害： 执行恶意操作（被转账，被发垃圾评论），制造蠕虫。。。等 概念： 利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作 原理principle： 通常Cookie当中会存放用户凭证信息，浏览器在发送请求时，会自动带上已有的cookie,通过cookie识别用户身份，执行转账操作。 例如，黑客构造转账服务的攻击代码，假如用户已经登陆，只要访问这个页面，就会自动将钱转到另一个用户。 3. 点击劫持通过覆盖不可见的框架误导受害者点击而造成的攻击行为。 特点： 隐蔽性比较高，骗取用户操作，UI-覆盖攻击， 利用iframe或者其他标签的属性（如：display:none） iframe: 是可以创建另一个包含另一个文档的内联框架 4. URL跳转定义： 借助为验证的url跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。例如：在互联网中，恶意的网站通常会设计成目标网站会经常访问的样子，这样才更具诱惑性。 实现方式： Header头跳转，js跳转，META标签跳转 5. SQL注入首先举个万能密码的例子：我们登陆网站要输入账号密码，错误将登陆失败，然后，我们在账号输入admin’ –,密码不输入，结果登陆成功。 定义： SQL Injection,是一种常见的WEB安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 解释： 登陆发送一个POST请求，提交参数是账号和密码，然后后台执行SQL时，利用代码 ‘ –, 闭合注释，达到登陆成功。 获取用户请求参数 拼接到代码当中 SQL语句按照我们构造参数的语义执行成功 本质就是 数据与代码未分离，即数据当做了代码来执行 危害： 获取数据库信息，获取服务器权限，植入webshell，获取服务器后门，读取服务器敏感文件，万能密码。。。 6. 命令注入 Command Injection windows: DOS命令， linux: Bash命令 命令拼接&amp;,依次执行拼接的命令，echo hello &amp; echo world 管道符|，前面命令的输出作为后面命令的输入， ipconfig | find “IPv4” 例如： PHP可执行命令的函数：system,exec, eval,shell_exec，。。。。。 过程： 黑客构造命令提交给web应用程序，程序提取被构造的命令，拼接到被执行的命令中，导致web应用程序执行了额外的命令，将执行结果显示到响应页面中。 7. 文件操作漏洞 file operation 文件上传： 上传webshell, 上传木马 文件上传不当：例如可以上传可执行脚本，脚本拥有执行权限 文件下载： 下载系统任意文件，下载程序代码 会导致代码泄露，数据库配置文件泄露，系统文件泄露。。。 文件处理不当导致：未验证下载文件格式，为限制请求的路径 文件包含 解决代码量，重复代码写入一个文件 本地文件包含，远程文件包含 下面是一些php中常见的文件包含函数：include()、require()、include_once()、require_once()….]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web基础知识]]></title>
    <url>%2F2017%2F11%2F12%2F%E7%A7%BB%E5%8A%A8web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[移动web基础知识一.pixel 移动开发像素知识px: css pixel 逻辑像素，浏览器使用的抽象单位 dp,pt： device independent pixels 设备无关像素 dpr: devicePixelRatio 设备像素比缩放 计算公式： 1px = (dpr)2 * dp DPI: 打印机每英寸可以喷的墨汁点（印刷行业） PPI： 屏幕每英寸的像素数量，即单位英寸内的像素密度 目前，在计算机显示设备惨呼描述上，两者意思表达的是一样的 计算公式： 以iphone5为例 ppi = √ (1136^2 + 640^2) /4 = 326ppi(视网膜Retina屏) 注意： 单位为硬件像素，非px | ldpi | mdpi | hdpi | xhdpi ppi | 120 | 160 | 240 | 320默认缩放比| 0.75 | 1.0 | 1.5 | 2 Retina屏（高清屏）： dpr都是等于大于2 二.viewport手机浏览器默认为我们做了两件事情 页面渲染在1个980px(ios)的viewport 缩放&gt; 为什么渲染时，要有Viewport? 为了渲染正确 viewport分为2种： visual viewport(度量/视口) = 窗口缩放sclce layout viewport(布局viewport) 为什么不适用默认的980px的布局viewport? 宽度不可控制，不同系统不同设备的默认值都可能不同 页面缩小版显示，交互不友好 链接不可点 有缩放，缩放后又有滚动 font-size为40px等于PC上12px同等物理太少,不规范* 三. meta标签&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;name=value,name=value&amp;quot;&amp;gt; width: 设置布局viewport的特定值（“device-width”指设备宽度） initial-scale: 设置页面的初始缩放 minimun-sacle: 最小缩放 maximun-sacle: 最大缩放 user-scalable: 用户能否缩放&gt; 注意： initial-scale自带width = deviece-width 移动web最佳viewport设置 [布局viewport] = [设备宽度] = [度量viewport] 常用设置： &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1,user-scalable=no&amp;quot;&amp;gt; 四.设计移动Web方案一：根据设备的实际宽度来设计（常用） 手机宽320px,我们就拿320px设计 方案二：1px = 1dp（淘宝用过） 缩放0.5，根据设备的物理像素dp等于抽象像素px来设计。1像素边框和高清图片都不需要额外处理 五.移动web布局不定宽高的水平垂直居中 .wrap{position:absoulue;top:50%;left:50%;z-index:3;-webkit-transform: translate(-50%,-50%);} flexbox版：.wrap{justify-content:center,;align-itens: center;display: -webkit-flex} flex布局就不多说了，可以搜一下,我之前有写一个demo flex 有兼容性 -ios 可以使用最新的flex布局-android4.4以下，只能兼容旧版的flexbox布局-android4.4以上，可以使用最新的flex布局 六.响应式设计响应式设计，常用媒体查询，例如@media screen and (max-width: 1024){....} 媒体类型： screen(屏幕) print(打印机) handheld(手持设备) all(通用) 常用媒体查询参数: width —— 视口宽高 height ——视口宽高 device-width ——– 设备的宽度 device-height ——- 设备的高度 orientation ——- 检查设备处于横向（landscape）还是竖屏（portrait） 设计点一： 百分比布局。没有任何平滑渐变 设计点二: 弹性图片 设计点三： 重新布局，显示与隐藏 当页面达到手机屏幕宽度的时候，很多时候就要放弃一些传统的页面设计思想，力求页面简介，所以我们必须做出一些处理： 1.同比例缩减元素尺寸 2.调整页面结构布局 3.隐藏多余的元素 注意： 经常需要切换位置元素使用【绝对定位】，减少重绘提高渲染性能 所以，使用响应式布局，性能不是最优，但是减少重复开发，一个页面包含所有设备。 七.特殊样式处理1.高清图片 在移动web页面上渲染图片，为了避免产生模糊，图片的宽高应该用物理像素单位渲染，即是100_100的图片，应该使用100dp_100dp width(w_value/dpr)px; height(h_value/dpr)px; 2.一像素边框问题 同样是retina屏幕下的问题，根本原因： 1px 使用2dp渲染 border:0.5px（仅仅ios8可用） sacleY(.5) 相对单位rem:为了适应个大屏幕的手机，px略显固定，不能根据尺寸的大小来改变，使用相对单位更能体验页面兼容性 em: 是根据父节点的font-size为相对单位 rem: 是根据html的font-size为相对单位 em在多层嵌套下，变得非常难控制，rem更加能作为全局统一设置的度量 remm的基值设置多少好？ 回归我们的目的：为了适应个大手机屏幕 rem = screen.width/20 width: px/rem基值 | height: px/rem基值 注意： 不使用rem的情况：font-size，因为字体的大小是趋向于阅读的实用性，并不适合与排版布局 3.多行文本溢出… 八.移动web事件 300ms延迟&gt; 在默认的viewport(980px)的页面，旺旺需要双击或者捏开放大页面。正是为了确认用户是双击，还是单击。 safari需要300ms的延迟来判断，而后来的iphone也一直沿用这样的设计，借鉴于成功iphone的android也沿用了这样的设计，于是‘300ms’成了一种规范 touch 有一个bug: android 只会触发一次touchstart,依次touchmove,touchend不触发（android4.0 4.1有，4.2没有，4.4又回来，直到5.0） 解决方案： 在touchmove中加入 ： event.preventDefault(),可fixedBug 注意：event.preventDefault()会导致默认行为不发生，如scroll,导致页面不滚动 弹性滚动 局部滚动开启弹性滚动：body{overflow:scroll;-webkit-overflow-scrolling:touch;} 注意： Android不支持原生的弹性滚动！但可以借助三房库iScroll来实现 下拉刷新 上拉加载]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F26%2FHello-World-0%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new “My New Post”More info: Writing### Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
